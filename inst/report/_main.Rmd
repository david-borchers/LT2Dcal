# Introduction
```{r initial-setup, include = FALSE, warning=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
source("code.R")
```
Accurate estimation of animal abundance is a fundamental aspect of ecological research and wildlife conservation. Since total enumeration are rarely possible for natural populations of animals, robust estimation methods have to be used. Commonly used approaches for estimating animal abundance include mark-recapture, distance sampling, and mark-recapture distance sampling (MRDS). Each of these methods relies on different principles and assumptions to estimate population sizes.

The mark-recapture method is based on capturing and marking individuals, followed by subsequent recapture efforts to estimate the total population size. Distance sampling, on the other hand, involves estimating the detection probability of individuals at different distances from the observer, allowing for the extrapolation of population size based on detection functions. MRDS is an extension that accounts for both the detection probabilities of individuals at different distances and the potential for recapture of marked individuals, providing more precise estimates, even when assumptions of closed populations and uniform detection probabilities are not fully met.

However, the accuracy and reliability of these estimation methods depend heavily on how well their underlying assumptions are met. Assumptions such as closed population, random sampling, and homogeneous detection probabilities play a crucial role in determining the performance of the models. When these assumptions are violated, the estimates obtained from the methods can be biased and lead to misleading conclusions.

2D Distance sampling is a new method that has the potential to work when these other methods fail. It uses a similar principle to distance sampling but the observers collect the forward distance as well as the perpendicular distance to the animal. This additional data allows the model to be flexible when dealing with different animal distributions and detection functions. 

In this study, we systematically tested the four methods using a range of scenarios with varying degrees of assumption compliance and violations. By simulating populations with known abundance and detectability patterns, we aimed to assess how each method performed under different conditions. We have based our populations on snow leopard prey data from Gobi Gurvansaikhan National Park. In the following sections of this report, we will present the methodology of our simulation study and the results obtained from the simulations. We will then use 2D distance sampling to analyse the snow leopard prey data. 


<!--chapter:end:01-intro.Rmd-->

# Mark-recapture {#cross}

Mark-recapture is a powerful technique used in ecology and wildlife biology to estimate the population size of a specific animal or species within a given area. This method is based on the concept of sampling, marking, and then recapturing individuals from the target population. By utilizing this approach, researchers can extrapolate the population size and gain valuable insights into population dynamics, species abundance, and conservation efforts.

The fundamental principle behind mark-recapture lies in the idea that the probability of capturing an individual within the population is the same for each capture event. Once an individual is captured, it is marked in some way, making it distinguishable from other members of the population. The marked individuals are then released back into the wild, allowing them to mix freely with the unmarked individuals. Subsequently, during the recapture phase, researchers perform another sampling effort, capturing a new group of individuals from the population. The proportion of marked individuals in the recaptured sample allows scientists to estimate the total population size based on the assumption of a closed population.

In this chapter, we explore the principles and applications of mark-recapture methods, focusing on the Lincoln-Peterson MR estimator in closed populations and the importance of simulation studies to evaluate method performance.

## Closed populations

The Lincoln-Peterson MR estimator is one of the most classic and widely used methods for estimating the population size of closed populations. Proposed independently by Peterson in the 1890s and by Lincoln in the 1920s, this estimator relies on two sampling events: the initial capture, where a subset of the population is marked, and the subsequent recapture, where the marked individuals are identified among the newly captured individuals.

The Chapman mark-recapture estimator is a modified version of the traditional Lincoln-Peterson estimator with less bias and is less affected by zeros.

::: {#tri .theorem}
**Chapman MR estimator (1951)** $$\hat{N}_{CPM} = \frac{(n_{1} + 1)(n_{2} + 1)}{m_{2}+1}-1$$

where:

-   $\hat{N}_{CPM}$ is the estimated population size.

-   $n_{1}$ is the number of individuals captured and marked in the first occasion.

-   $n_{2}$ is the number of marked individuals recaptured in the second occasion.

-   $m_{2}$ is the number of recaptured individuals that were already marked in the first occasion.
:::

The accuracy of this estimate relies on a number of assumptions being met.

| **Assumption 1.** The population is closed to additions and deletions;

In other words, no individuals are added to or removed from the population through birth, death, immigration, or emigration during the study period. An exception is when there are equal proportions of additions or deletions for marked and unmarked individuals during the sampling period. In cases where significant movements occur, potential bias might need to be introduced to the results or more advanced models might be needed to account for population dynamics.

| **Assumption 2.** All animals are equally likely to be captured in each sample;

Sometimes after initial capture, animals may learn to avoid the traps or area where the capture occurred, causing them to be captured less frequently ("trap shy"). The opposite ("trap happy") may also occur, making them more likely to be captured. Individuals may also inherently different capture probabilities, and if ignored, the resulting abundance estimates are likely to be negatively biased.

| **Assumption 3.** Marks are not lost and not overlooked by the observer

It is possible that marks may fade, fall off, or be lost over time, making individuals indistinguishable from unmarked ones during recapture events. Ensuring durable and effective marking techniques is essential to maintain the integrity of the mark-recapture process and achieve unbiased estimates.

## Simulation study

Simulation studies have become indispensable in ecology and conservation research, providing a controlled and repeatable approach to evaluate the performance of estimation methods. In this section, we will present the results of a simulation study that aims to evaluate the performance of the Lincoln-Peterson MR estimator in closed populations. We will create artificial datasets with with known population sizes, detectability patterns to assess the accuracy and precision of estimators under different scenarios.

For each scenario we simulate 999 surveys, with each survey having a simulated sample size $N = 500$.

### Scenario 1: When the underlying assumptions are met

We first looked into the performance of mark-recapture estimator when all the above assumptions are met. Specifically, we will create artificial datasets to mimic a closed population, equal probability of detection of marked and unmarked individuals ($p = 0.4$), and random sampling. For each replication, we will compare the estimated population size to the true population size ($N = 500$). We then calculate the mean estimate and the variance of the estimates across replications and thus check with the coverage probability.

```{r simulated data, message=FALSE, cache = TRUE}
library(circular)
library(fields)

sim.mr <- function(n, move, equal.p, param){
  #browser()
  ## 1. object positions
  df <- data.frame(id=rep(1:n, each = 2), obs=rep(1:2, n),
                   x=NA, y=NA, distance=NA, detect=NA)
  
  df$x[df$obs==1] <- runif(n, 0, 2); df$y[df$obs==1] <- runif(n, 0, 2)
  df$distance[df$obs==1] <- df$x[df$obs==1] - 1
  
  if (move==0){
    angle <- as.numeric(rwrappedcauchy(n, mu = circular(0),rho = 0))
    distance <- abs(rnorm(n, 0.1, 0.1))
    df$x[df$obs==2] <- df$x[df$obs==1] + distance*cos(angle)
    df$y[df$obs==2] <- df$y[df$obs==1] + distance*sin(angle)
  }else{
    df$x[df$obs==2] <- runif(n, 0, 2)
    df$y[df$obs==2] <- runif(n, 0, 2)}
  
  df$distance[df$obs==2] <- df$x[df$obs==2] - 1
  
  
  ## 2. detection probability & Mark-Recapture
  if (equal.p == TRUE){
    p1 <- p2 <- param
  }else{
    p1 <- exp(-abs(df$distance[df$obs==1])^2/(2*param^2))
    p2 <- exp(-abs(df$distance[df$obs==2])^2/(2*param^2))}
  
  df$detect[df$obs==1] <- rbinom(n, 1, p1)  # first occasion
  df$detect[df$obs==2] <- rbinom(n, 1, p2)  # second occasion
  
  
  ## 3. return
  return(df)
}
```

```{r imperfect-matching, cache = TRUE}
sim.mismatch <- function(df, equal.p, param){
  #browser()
  
  ## 1. get distance between every pair of detected objects
  df1 <- subset(df, df$obs==1 & df$detect==1)[ , c("x", "y")]  
  df2 <- subset(df, df$obs==2 & df$detect==1)[ , c("x", "y")]  
  dist.pair <- as.data.frame(rdist(df1, df2))
  
  dist.pair$unique <- 1:nrow(dist.pair)
  df1$id <- 1:nrow(df1); df1$detect <- df1$obs <- rep(1, nrow(df1))
  
  
  ## 2. using min distance to decide mismatching
  for (i in 1:(ncol(dist.pair)-1)) {
    min.index <- which.min(dist.pair[, i])
    if (length(min.index)>0){  
      if (dist.pair[min.index, i] < 0.1) {detect2 <- 1}
      else if (dist.pair[min.index, i] > 0.9) {detect2 <- 0}
      else{
        if (equal.p==TRUE) {detect2 <- rbinom(1, 1, param)}
        else {detect2 <- rbinom(1, 1, exp(-dist.pair[min.index, i]^2/(2*param^2)))}}
    }else{detect2 <- 0}  # if no obs1 detection to match
    
    if (detect2==1){  # if matched
      df1[nrow(df1) + 1, ] <- c(df2$x[i], df2$y[i], dist.pair$unique[min.index], 2, 1)
      dist.pair <- dist.pair[-min.index, ]
    }else{  # if no match
      id <- max(unique(df1$id))+1
      df1[nrow(df1) + 1, ] <- c(df2$x[i], df2$y[i], id, 1, 0)
      df1[nrow(df1) + 1, ] <- c(df2$x[i], df2$y[i], id, 2, 1)}}
  
  for (i in dist.pair$unique){ 
    df1[nrow(df1) + 1, ] <- c(df1$x[df1$id==i], df1$y[df1$id==i], i, 2, 0)}
  
  
  ## 3. return new dataset
  df1 <- df1[order(df1$id), ]
  return(df1)
}

```

```{r Chapman MR, cache = TRUE}
chapman.mr <- function(n, move, equal.p, param, mismatching){
  df <- sim.mr(n, move, equal.p, param)
  if (mismatching==TRUE){df <- sim.mismatch(df, equal.p, param)}
  
  S1 <- nrow(df[df$obs==1 & df$detect==1, ])  # first occasion
  S2 <- nrow(df[df$obs==2 & df$detect==1, ])  # second occasion
  B <- df$detect[df$obs==1]==1 & df$detect[df$obs==2]==1  
  B <- length(B[B==TRUE])  # caught by both occasions
  N.hat <- (S1+1)*(S2+1)/(B+1)-1  # abundance estimate
  var.N <- (S1+1)*(S2+1)*(S1-B)*(S2-B)/(((B+1)^2)*(B+2))
  d <- exp(1.96*sqrt(log(1+(var.N/(N.hat^2)))))
  return(c(N.hat, d))
}
```

```{r bootstrap simulation, cache = TRUE}
boot.mr <- function(n, move, equal.p, param, mismatching){
  input <- rep(n, 999)
  ests <- lapply(input, chapman.mr, move, equal.p, param, mismatching)
  df.ests <- data.frame(t(sapply(ests,c)))
  colnames(df.ests) <- c("N.hat", "d")
  return(df.ests)
}
```

```{r cache = TRUE}
ests <- boot.mr(500, 0, TRUE, 0.4, FALSE)  # bootstrap estimates
ci <- mean(ests$N.hat) + c(-1, 1)*1.96*sqrt(var(ests$N.hat)/999)
bias <- mean((ests$N.hat-500)/500)  # mean relative bias
check.pcover <- 500 > ests$N.hat/ests$d & 500 < ests$N.hat*ests$d
coverage.p <- length(check.pcover[check.pcover==TRUE])/length(check.pcover)
ci; sprintf("%1.2f%%", bias*100); coverage.p
```

The result above shows that Chapman estimator of abundance is unbiased as the 95% CI covers the true population size and the mean percentage relative bias is very close to 0.

### Scenario 2: When there has imperfect matching

We are interested in how imperfect matching influence the abundance estimate given that all other assumptions (e.g. equal capture probability) are met. The result below shows that failure to account for imperfect matching leads to largely biased abundance estimate.

```{r cache = TRUE}
N <- 200
ests <- boot.mr(N, 0, TRUE, 0.4, TRUE)  # bootstrap estimates 
ci <- mean(ests$N.hat) + c(-1, 1)*1.96*sqrt(var(ests$N.hat)/999) 
bias <- mean((ests$N.hat-N)/N)  # mean relative bias 
check.pcover <- N > ests$N.hat/ests$d & N < ests$N.hat*ests$d 
coverage.p <- length(check.pcover[check.pcover==TRUE])/length(check.pcover) 
ci; sprintf("%1.2f%%", bias*100); coverage.p
```

### Scenario 3: When inherent capture probabilities are different

In this scenario, we aim to examine the impact of deviations from equal detectability assumption on the accuracy and bias of mark-recapture method. We make probability of detection falls off with distance from the transect line following half-normal distribution in both occasion. Different half-normal parameters are fitted to investigate how they affect the estimate.

#### *i. complete random animal movement*

When animals move completely random between two occasions, the result shows that larger value of sigma, i.e. when detectability decreases less rapidly with increasing distance, leads to more precise estimates. The abundance estimate is rather accurate for each detection function used ($\sigma = 0.3, 0.5, 0.7$). The explanation behind this is that the estimator is likely to be biased when the probabilities of detection are correlated by the two observers, however, in this case complete random animal movement does not lead to a correlated detection probabilities and thus negatively biased estimates.

```{r MR2.1}
plot1.1 <- function(n){
  N1 <- boot.mr(n, 1, FALSE, 0.3, FALSE)$N.hat
  N2 <- boot.mr(n, 1, FALSE, 0.5, FALSE)$N.hat
  N3 <- boot.mr(n, 1, FALSE, 0.7, FALSE)$N.hat
  boxplot(c(N1, N2, N3)~rep(c(0.3, 0.5, 0.7), each = 999),
          data=ToothGrowth,
          main="Abundance estimates for different detection functions",
          xlab="sigma",
          ylab="Estimates",
          border="black")
  abline(h=500, col="blue", lty=2, lwd=1.5)
}
```

```{r}
plot1.1(500)  # N = 500
```

#### *ii. random animal movement over short distances*

We then take a look at the case where animals make random movement over short distances between two occasions. As shown in the graph below, when detectability decreases more rapidly with increasing distance ($\sigma = 0.3$), the estimate are more negatively biased. In contrast, if there has less difference between detection probability on the transect and deetction probability on the truncation ($\sigma = 0.7$), then abundance estimate are less negatively biased.

```{r MR2.2}

plot1.2 <- function(n){
  #browser()
  par(mfrow=c(1,2))
  
  ## plot 1: half-normal
  x <- seq(0, 1, 0.01)
  y1 <- exp(-x^2/(2*0.3^2))
  y2 <- exp(-x^2/(2*0.5^2))
  y3 <- exp(-x^2/(2*0.7^2))
  plot(x, y1, main = "Half normal", xlab = "Distance", ylab = "Detection probability",
       type="l", lwd=1.5, col="red", xlim=c(0, 1))
  lines(x, y2, col="blue", lwd=1.5, lty=2)
  lines(x, y3, col="darkgreen", lwd=1.5, lty=3)
  legend(x = "topright", legend = c("sigma = 0.3", "sigma = 0.5", "sigma = 0.7"),  
         lty = c(1, 2, 3), col = c("red", "blue", "darkgreen"), lwd = 1.5, cex=0.5) 
  
  
  ## plot 2: bootstrap abundance estimates
  N1 <- boot.mr(n, 0, FALSE, 0.3, FALSE)$N.hat
  N2 <- boot.mr(n, 0, FALSE, 0.5, FALSE)$N.hat
  N3 <- boot.mr(n, 0, FALSE, 0.7, FALSE)$N.hat
  plot(0.3, mean(N1), pch=7, col="red", xlim=c(0.2, 0.8), ylim=c(min(N1), n+10), xlab="sigma", ylab="estimates")
  title(main="Mean estimates, N = 500", cex.main=1)
  points(0.5, mean(N2), pch=7, col="blue")
  points(0.7, mean(N3), pch=7, col="darkgreen")
  abline(h=n, lwd=1.5)
  x <- seq(0.3, 0.7, 0.02)
  y <- NULL
  for (i in x){
    meanN <- mean(boot.mr(n, 0, FALSE, i, FALSE)$N.hat)
    y <- c(y, meanN)}
  lines(x, y, lty=3, lwd=1.5)
  legend(x = "bottomright", legend = c("sigma = 0.3", "sigma = 0.5", "sigma = 0.7"),  
         pch = c(7, 7, 7), col = c("red", "blue", "darkgreen"), cex=0.5) 
}
```

```{r}
plot1.2(500)  # N = 500
```

## Further Reading

Borchers, D.L., Buckland, S.T. and Zucchini, W. (2002). Estimating Animal Abundance: Closed Populations. Springer London. <https://doi.org/10.1007/978-1-4471-3708-5>

<!--chapter:end:02-mark-recapture.Rmd-->

# Distance sampling

Distance sampling is another widely used method in ecological research or estimating animal abundance and density. Here we focus on conventional distance sampling, the fundamental distance sampling techniques among all.

## 3.1 Line transect sampling

Usually, observers travel along the transect lines that are strategically placed across the study area to ensure coverage of different habitats and representative sampling of the population. Upon detecting an object, they record the perpendicular distance from the line to the identified object. In some cases, additional information, such as the angle of detection or group size are also recorded for the purpose of multiple-covariate distance sampling (MCDS) analysis.

Detection function $g(x)$describes the probability of detecting an animal at different distances from the transect lines. A fundamental assumption is that all objects present on the line are detected, i.e. $g(0)=1$ ; however it is expected that objects become progressively more challenging to detect as their distance from the line increases, leading to a decrease in detection with increasing distance. Commonly used detection functions include uniform, half-normal and hazard rate. Example of adjustment terms include cosine, Hermite polynomial series and simple polynomial series.

```{r detection func}
detection <- function(){
  hn.sigma <- c(0.2, 0.3, 0.4)
  hr.sigma <- 0.3; hr.beta <- c(1, 2, 5)
  
  x <- seq(0, 1, 0.01)
  y.unif <- x/x
  y.hn1 <- exp(-x^2/(2*hn.sigma[1]^2)); y.hn2 <- exp(-x^2/(2*hn.sigma[2]^2)); y.hn3 <- exp(-x^2/(2*hn.sigma[3]^2))
  y.hr1 <- 1-exp(-(x/hr.sigma)^(-hr.beta[1])); y.hr2 <- 1-exp(-(x/hr.sigma)^(-hr.beta[2])); y.hr3 <- 1-exp(-(x/hr.sigma)^(-hr.beta[3]))
  
  par(mfrow=c(1,3))
  plot(x, y.unif, type="l", col="red", xlab="Distance", ylab="Detection probability", main="Uniform", ylim=c(0, 1))
  
  plot(x, y.hn1, type="l", lwd=1.5, col="red", xlab="Distance", ylab="Detection probability", main="Half-normal", ylim=c(0, 1))
  lines(x, y.hn2, col="darkgreen", lty=2, lwd=1.5)
  lines(x, y.hn3, col="steelblue", lty=3, lwd=1.5)
  legend(x = "topright", legend = c("sigma = 0.2", "sigma = 0.3", "sigma = 0.4"),  
         lty = c(1, 2, 3), col = c("red", "darkgreen", "steelblue"), lwd = 1.5, cex=0.5) 
  
  plot(x, y.hr1, type="l", lwd=1.5, col="red", xlab="Distance", ylab="Detection probability", main="Hazard rate (sigma = 0.3)", ylim=c(0, 1))
  lines(x, y.hr2, col="darkgreen", lty=2, lwd=1.5)
  lines(x, y.hr3, col="steelblue", lty=3, lwd=1.5)
  legend(x = "topright", legend = c("beta = 1", "beta = 2", "beta = 5"),  
         lty = c(1, 2, 3), col = c("red", "darkgreen", "steelblue"), lwd = 1.5, cex=0.5) 
  
}
```

```{r}
detection()  # plot detection functions
```

Once the detection function is fitted, the estimator can calculate animal density and thus abundance by accounting for the area surveyed and the proportion of animals detected at different distances. The obtained abundance estimates can be extrapolated to the entire study area if the survey design is representative of the entire habitat.

::: {#tri .theorem}
**Animal density** $D$ **is estimated by:** $$\hat{D} = \frac{n}{2wL\hat{P}_a}$$

$$\hat{P}_a = \frac{\int_{0}^{w}\hat{g}(x)dx}{w}$$

where:

-   $n$ is the number of animals detected.

-   $w$ is the half-width of the strip.

-   $L$ is the lengths of transect lines.

-   $\hat{P}_a$ is the probability that a randomly chosen animal within the surveyed area is detected.

-   $\hat{g}(x)$ is the estimate of detection function.
:::

## 3.2 Simulation study

In this section, we will present the results of a simulation study that aims to evaluate the performance of the conventional line transect sampling. We will create artificial datasets with with known population sizes, detectability patterns to assess the accuracy and precision of the method under different scenarios.

For each scenario we simulate 99 surveys, with each survey having a simulated sample size $N$ = 500.

### Scenario 1: When the underlying assumptions are met

We investigate how well the method performs when $p(0) = 1$ assumption is met and animals are uniformly distributed. For each replication, we will compare the estimated abundance to the true population size ($N$ = 500). The detection function chosen is half-normal with $\sigma = 0.4$ . We then calculate the mean estimate and the variance of the estimates across replications and thus check if true population size is within the confidence interval of the estimates.

The result below shows that the abundance estimate is unbiased as the 95% CI covers the true population size and the mean percentage relative bias is very close to 0.

```{r simulated data DS, message=FALSE, cache = TRUE}
sim.data.ds <- function(n, sigma){
  #browser()
  ## 1. generate n uniform points 
  df <- data.frame(id=rep(1:n, each = 2), obs=rep(1:2, n),
                   x=NA, y=NA, distance=NA, detect=NA, angle=NA)
  df$x[df$obs==1] <- runif(n, 0, 2)
  df$y[df$obs==1] <- runif(n, 0, 2)
  df$distance[df$obs==1] <- df$x[df$obs==1] - 1
  
  ## 2. Points moving away from transect
  # moving angle & distance
  nleft <- nrow(df[df$x <= 1 & df$obs==1, ])
  nright <- nrow(df[df$x > 1 & df$obs==1, ])
  
  angleleft <- rwrappedcauchy(nleft, mu=circular(pi), rho=0.8, control.circular=list(units="radian"))
  df$angle[df$x <= 1 & df$obs==1] <- as.numeric(angleleft)
  angleright <- rwrappedcauchy(nright, mu=circular(0), rho=0.8, control.circular=list(units="radian"))
  df$angle[df$x > 1 & df$obs==1] <- as.numeric(angleright)
  
  dist <- (1-abs(df$distance[df$obs==1]))*runif(n, 0, 0.2)*3
  df$x[df$obs==2] <- df$x[df$obs==1] + dist * cos(df$angle[df$obs==1])
  df$y[df$obs==2] <- df$y[df$obs==1] + dist * sin(df$angle[df$obs==1])
  df$distance[df$obs==2] <- df$x[df$obs==2] - 1
  
  
  ## 3. detection probability, half-normal
  p1 <- exp(-abs(df$distance[df$obs==1])^2/(2*sigma^2))
  p2 <- exp(-abs(df$distance[df$obs==2])^2/(2*sigma^2))
  
  df$detect[df$obs==1] <- rbinom(n, 1, p1)  # first situation
  df$detect[df$obs==2] <- rbinom(n, 1, p2)  # second situation
  df$detect[abs(df$distance) > 1] <- 0  # truncation
  
  
  ## 4. return
  df[ , c("angle")] <- list(NULL)
  return(df)
}
```

```{r cache = TRUE}
ds.analysis <- function(n, sigma, movement){
  #browser()
  df <- sim.data.ds(n, sigma)
  
  if (movement == TRUE){
    df1 <- subset(df, df$obs==2 & df$detect==1)
    n <- nrow(df1)
    new_df1 <- data.frame(Region.Label = rep(1, n), Area = rep(4, n), 
                          Sample.Label = rep(1, n), Effort = rep(2, n),
                          distance = df1$distance)
    df.ds <- ds(new_df1, truncation=1, transect="line", key="hn", order=0, monotonicity = "none")
  }else{
    df1 <- subset(df, df$obs==1 & df$detect==1)
    n <- nrow(df1)
    new_df1 <- data.frame(Region.Label = rep(1, n), Area = rep(4, n), 
                          Sample.Label = rep(1, n), Effort = rep(2, n),
                          distance = df1$distance)
    df.ds <- ds(new_df1, truncation=1, transect="line", key="hn", monotonicity = "none")}
  
  return(c(df.ds$ddf$Nhat, df.ds$dht$individuals$N$lcl, df.ds$dht$individuals$N$ucl))
}


boot.ds <- function(n, sigma, movement){
  input <- rep(n, 99)
  ests <- lapply(input, ds.analysis, sigma, movement)
  df.ests <- data.frame(t(sapply(ests,c)))
  colnames(df.ests) <- c("N.hat", "lcl", "ucl")
  return(df.ests)
}
```

```{r message=FALSE, warning=FALSE, cache = TRUE}
ests.ds <- boot.ds(500, 0.4, FALSE)  # bootstrap estimates
ci.ds <- mean(ests.ds$N.hat) + c(-1, 1)*1.96*sqrt(var(ests.ds$N.hat)/99)  # confidence interval
bias.ds <- mean((ests.ds$N.hat-500)/500)  # mean relative bias
check.pcover.ds <- 500 > ests.ds$lcl & 500 < ests.ds$ucl
coverage.p.ds <- length(check.pcover.ds[check.pcover.ds==TRUE])/length(check.pcover.ds)  # coverage probablity
ci.ds; sprintf("%1.2f%%", bias.ds*100); coverage.p.ds
```

### Scenario 2: When animals show responsive movement

Apart from assuming that objects on the transect line are certain to be detected, another model assumption of distance sampling is that objects are detected at their initial location. Here we aim to examine the validity of method when animals move in response to the observer (away from transect line in this case) before being detected. The detection function chosen is half-normal with $\sigma = 0.4$ . The result above shows that the abundance estimate is negatively unbiased with mean percentage relative bias being about 50%.

```{r cache = TRUE}
ds.result <- function(n, sigma, movement){
  #browser()
  par(mfrow=c(1,2))
  
  ## plot 1: animal distribution
  df <- sim.data.ds(n, sigma)
  ddist <- density(df$distance[df$obs==2]+1)
  plot(ddist, main="Animal distribution after responsive movement", xlab="", ylab="")
  polygon(ddist, col="lightgrey")
  
  
  ## plot 2: histogram of bootstrap abundance estimates
  ests <- boot.ds(n, sigma, movement)
  est.N <- ests$N.hat
  hist(est.N, main=paste("Abudance estimates"), xlab=NULL, ylab = NULL, prob=TRUE)
  points(mean(est.N),0,pch=19,col="red")
  arrows(quantile(est.N, 0.025),0,quantile(est.N, 0.975),0,angle=90,code=3,col="red")
  
  return(ests)
}
```

```{r ds responsive movement, message=FALSE, warning=FALSE, cache = TRUE}
ests.ds2 <- ds.result(500, 0.4, TRUE)
```

```{r}
ci.ds2 <- mean(ests.ds2$N.hat) + c(-1, 1)*1.96*sqrt(var(ests.ds2$N.hat)/99)  # confidence interval
bias.ds2 <- mean((ests.ds2$N.hat-500)/500)  # mean relative bias
check.pcover.ds2 <- 500 > ests.ds2$lcl & 500 < ests.ds2$ucl
coverage.p.ds2 <- length(check.pcover.ds2[check.pcover.ds2==TRUE])/length(check.pcover.ds2)  # coverage probablity
ci.ds2; sprintf("%1.2f%%", bias.ds2*100); coverage.p.ds2
```

```{r table DS, tidy=FALSE}
tab.ds <- data.frame(scenario=c("No responsive movement", "Has responsive movement"), mean.relative.bias=c(bias.ds, bias.ds2), coverage.probablity=c(coverage.p.ds, coverage.p.ds2))
knitr::kable(tab.ds, caption = 'A table of results from both scenarios', booktabs = TRUE)
```

## Further Reading

Buckland, S.T., Rexstad, E.A., Marques, T.A. and Oedekoven, C.S. (2015). Distance Sampling: Methods and Applications. Springer International Publish. <https://doi.org/10.1007/978-3-319-19219-2>

<!--chapter:end:03-distance-sampling.Rmd-->

# Mark Recapture Distance Sampling

```{r mrds-setup, include = FALSE}
#set up
Nanimals = 500
hr_param = c(374.7160,2.2416) #parameters for detection function
match_limits = c(300,1000)
match_param = c(450,5)
p0 = 0.8
```

## Introduction

Mark Recapture Distance Sampling (MRDS) combines the principles of mark-recapture and standard distance sampling. 2 observers each travel along the same transect and record the animals they see and the perpendicular distance. By including the capture history of each animal we have enough information to allow for non-zero detection probability on the line, but we lose the pooling robustness property, so unmodelled heterogeneity will cause biased estimates.

Point independence models, which assume the two observers' detection probabilities are uncorrelated at a specific distance, are less biased when faced with unmodelled heterogeneity than full independence models, which assume detection probabilities are independent at all distances. However, the estimates are still negatively biased in this situation. Unmodelled heterogeneity is likely to occur in most surveys as the observers are unlikely to be aware of every potential source of difference in detection and it is not feasible to record multitudes of information whilst moving along a transect.

One advantage of MRDS is that the extra data from the capture history means that it can be used for situations where the probability of detection on the line is not one. This can be useful for marine surveys, where animals on the transect line may be below the water and so not visible, or surveys in thickly forested areas where it is possible to not see animals high up in the canopy. 

This model also assumes that the observers perfectly match which animals they both saw and which ones only one observer saw. If the animals don't have uniquely identifying features and there is any kind of animal movement between surveys then this assumption will not hold.

## Simulation - p(0) \< 1 and animal movement
<!-- keep this section as not in main simulation chapter? -->

### Methods
To test the MRDS estimator, we simulated `r Nanimals` animals with a uniform distribution across the study area and simulated an observer detecting animals with a hazard rate detection function with sigma = `r hr_param[1]`, beta = `r hr_param[2]`, scaled by 0.8 to see the affect of p(0) \< 1. We then had the animals move away in response to the observer with three levels of avoidance, and simulated the second observer detecting the animals in their new positions with the same detection function as the first observer.

We fitted a half normal and a hazard rate MRDS model to this data and selected the best using AIC, and repeated this process 99 times to estimate bias.

```{r mrds-avoidance,echo = FALSE, fig.asp=1.25, fig.margin = TRUE, fig.cap='Demonstration of different avoidance levels'}
avoidance_demo(Nanimals, 0)
```

### Results

As expected, the MRDS estimator is approximately unbiased for p(0) \< 1 when there is no animal movement and no heterogeneity in the population. However, this may not be realistic for most situations. The estimate becomes more negatively biased as the animals move more as a result of the increasing difference in detectability between the two occasions.

```{r mrds-simulation, echo= F, warning=FALSE, cache = TRUE}
#p0.bias <- get_p0_bias(99,Nanimals, detectfn = "hr") 
load("p0.bias.Rdata")
```

```{r mrds-simulation-plotting, fig.cap="Bias for different levels of animal avoidance", echo = FALSE}
par(mar = c(6,4,1,1))
plot(p0.bias,pch = 16, xlab = "", ylab = "% Bias", ylim = c(min(p0.bias)-5, max(c(max(p0.bias),0))), xaxt = "n")
abline(h = 0, col = "blue", type = "dashed")
legend("bottom", inset=c(0,-0.2), legend=c("No", "Low","Medium", "High"), title="Avoidance", horiz = T, xpd = T)
```

## Conclusion
MRDS should be used in situations where it is suspected p(0) may be less than one and animals are uniformly distributed and uniquely identifiable. If it is used, the observers should collect as much information as is practical to prevent any unmodelled heterogeneity from causing bias. 
From our simulations, MRDS does not perform well in scenarios with non-uniform animal distribution. It is negatively biased when animals initially avoid the line and positively biased when they are attracted to it.  Imperfect matching has different affects in different scenarios, but generally makes the estimates worse and so should be avoided. 

## Futher Reading

Buckland, S.T., Rexstad, E.A., Marques, T.A. and Oedekoven, C.S. (2015). Distance Sampling: Methods and Applications. Springer International Publish, pp.99--103.

Borchers, D.L., Laake, J.L., Southwell, C. and Paxton, C.G.M. (2005). Accommodating Unmodeled Heterogeneity in Double-Observer Distance Sampling Surveys. *Biometrics*, [online] 62(2), pp.372--378. doi:<https://doi.org/10.1111/j.1541-0420.2005.00493.x.>

Burt, M.L., Borchers, D.L., Jenkins, K.J. and Marques, T.A. (2014). Using mark-recapture distance sampling methods on line transect surveys. Methods in Ecology and Evolution, [online] 5(11), pp.1180--1191. <doi:https://doi.org/10.1111/2041-210x.12294>.

<!--chapter:end:04-mrds.Rmd-->

# 2D Distance Sampling

```{r 2D-setup, include=FALSE, warning = FALSE}
source("code.R")
b = c(4.89553757, 0.03561984); logphi = c(6.61348904, 4.84269089)
w = 1600; ystart = 1300
Nanimals = 200
match_limits = c(300,1000); match_param = c(450,5)
```

## Introduction

2D Distance Sampling builds on standard distance sampling by including the forward distance to the detected animal as well as the perpendicular distance. This removes the assumptions that the animals are uniformly distributed and that p(0) = 1, so this method is useful for situations where the other methods covered previously are not suitable. In particular, 2D distance sampling only requires the transect to be surveyed by one observer. This is not only more efficient but removes the issue of imperfect matching in mark-recapture methods.

Animal movement is also less problematic for 2D distance sampling. Like in standard distance sampling, as long as the movement is slow relative to the speed of the observers it will only cause a small amount of bias. Responsive movement can be accounted for in the animal distribution model so does not cause bias.

The likelihood equation for this model is: $$
L(N, \boldsymbol{\beta}) = {N\choose n}[1-p.(\boldsymbol{\beta},\boldsymbol{\phi})]^{N-n}\prod_{i = 1}^{n}\pi(x_i; \boldsymbol{\phi})S(t_i, x_i; \boldsymbol{\beta}) h(t_i, x_i; \boldsymbol{\beta}) 
$$ where:

\- $n$ is the number of animals observed and $N$ is the total in the population

\- $\pi(x_i; \boldsymbol{\phi})$ is the probability animal i is at perpendicular distance $x_i$. We will refer to $\pi(x_i; \boldsymbol{\phi})$ as the animal distribution function.

\- $h(t_i, x_i; \boldsymbol{\beta})$ is the probability animal i is detected at forward distance $y_i$ and perpendicular distance $x_i$. We will refer to $h(t_i, x_i; \boldsymbol{\beta})$ as the detection function.

\- $S(t_i, x_i; \boldsymbol{\beta}) = e^{-\int_{0}^{t_i}h(u,x;\boldsymbol{\beta})du}$ is the survivor function, i.e. the probability that animal i was undetected until time $t_i$

\- $p.(\boldsymbol{\beta},\boldsymbol{\phi})$ is the average probability of being detected in the region

In practice the conditional likelihood $L(\boldsymbol{\beta}|n)$ is used to calculate the maximum likelihood estimators. It is the same as the equation above, but without the leading binomial term, and so avoids considering the unseen animals. $\hat N$ is then estimated using a Horvitz-Thompson like estimator. The forward distance to the detected animal $y_i$ is used instead of the time $t_i$.

## Simulation: Non Uniform Distribution

We start by simulating attraction to the line by generating 200 animals using a half normal distribution with parameters `r exp(logphi)`. We used a inverse power detection function with parameters `r b`. The parameters chosen are the best model for the real snow leopard prey data.

```{r 2D-simulation, echo = F, warning = F, cache = TRUE}
#suppressWarnings(simdata <- MCR_2D(99,Nanimals, b=b, logphi = logphi, w= w, ystart = ystart, match_limits = match_limits, match_param = match_param))
load("simdata.Rdata")
bias_2d <- 100*(simdata$X2D - Nanimals)/Nanimals
```

We then fitted a model using a half normal distribution for animal density and inverse power detection function. We did not fit any other models for efficiency purposes. This gives a bias of `r mean(bias_2d)` $\pm$ `r 1.96*sqrt(var(bias_2d)/length(bias_2d))`, so we can confirm it is unbiased.

## Simulation: Comparison to Mark Recapture

Double observer mark recapture methods using the Chapman estimator are the current standard for estimating abundance of snow leopard prey. Our previous simulations have shown these have serious flaws, so we used both a 2D distance model and the Chapman estimator to estimate the abundance from the same data (simulated using the same parameters as above).

```{r 2D-histograms, echo = F, fig.cap="Histograms of abundance estimates using 2D distance sampling and the Chapman estimator"}
par(mfrow = c(1,2))
hist(simdata$X2D, main = "2D Distance", xlab = "Estimate of N")
abline(v = Nanimals, col = "blue")
hist(simdata$MCR.nomvmnt, main = "Chapman", xlab = "Estimate of N", xlim = c(min(simdata$MCR.nomvmnt),max(c(max(simdata$MCR.nomvmnt),Nanimals))))
abline(v = Nanimals, col = "blue")
```

The Chapman estimator was significantly negatively biased due to the unmodelled heterogeneity in the population. Adding random animal movement and imperfect matching gives a similar problem.

```{r imperfect-matching-histograms, echo = F, fig.cap = "Histograms of abundance estimates using the Chapman estimator with random movment"}
par(mfrow = c(1,2))
hist(simdata$MCR.move, main = "Perfect Matching", xlab = "Estimate of N", xlim = c(min(simdata$MCR.move),max(c(max(simdata$MCR.move)+10,Nanimals))))
abline(v = Nanimals, col = "blue")
hist(simdata$MCR.imperf, main = "Imperfect Matching", xlab = "Estimate of N", xlim = c(min(simdata$MCR.imperf), max(c(max(simdata$MCR.imperf)+10,Nanimals))))
abline(v = Nanimals, col = "blue")
```

```{r coverage-probabilities, include=FALSE}
cis_2D <- simdata[!is.na(simdata$X2D.lower)&!is.na(simdata$X2D.lower), 2:3]
covprob2D <- 100*length(cis_2D[cis_2D$X2D.lower <= Nanimals &cis_2D$X2D.upper >= Nanimals])/length(cis_2D)
cp.nomvmnt <- 100*length(simdata[simdata$nomvmnt.lower <= Nanimals & simdata$nomvmnt.upper >= Nanimals])/length(simdata$MCR.nomvmnt)
if(length(dim(cis_2D)[1] == 0)){
  print("Hessian matrices could not be computed for any 2D models")
  covprob2D <- NA}
cp.mvmnt <- 100*length(simdata[simdata$mvmnt.lower <= Nanimals & simdata$mvmnt.upper >= Nanimals,])/length(simdata$MCR.move)
cp.imperf <- 100*length(simdata[simdata$imperf.lower <= Nanimals & simdata$nimperf.upper >= Nanimals,])/length(simdata$MCR.imperf)
kable(data.frame("2D" = covprob2D,"nm" = cp.nomvmnt, "m" = cp.mvmnt,"i" = cp.imperf), col.names = c("2D", "Chapman without movement", "Chapman with movement", "Chapman with imperfect matching"), caption = "Coverage Probabilities")
```

From this it is clear that double-observer mark-recapture will yield significantly biased estimates of abundance of snow leopard prey, even if the animals do not move and the observers can perfectly match the individuals seen. We recommend instead using 2D distance sampling, as it accounts for the non uniform animal distribution as well as the declining detectability with distance. It is also requires less time to be spent surveying, as each transect only need to be walked once.

## Further Reading

Borchers, D.L. and Cox, M.J. (2016). Distance sampling detection functions: 2D or not 2D? Biometrics, 73(2), pp.593--602. <doi:https://doi.org/10.1111/biom.12581>.

Borchers, D.L., Buckland, S.T. and Zucchini, W. (2002). Estimating Animal Abundance. [online] Springer Science & Business Media.

Suryawanshi, K.R., Bhatnagar, Y.V. and Mishra, C. (2012). Standardizing the double-observer survey method for estimating mountain ungulate prey of the endangered snow leopard. Oecologia, 169(3), pp.581--590. <doi:https://doi.org/10.1007/s00442-011-2237-0>.

<!--chapter:end:05-2d-distance.Rmd-->

# Simulation

Simulation studies have become indispensable in ecology and conservation research, providing a controlled and repeatable approach to evaluate the performance of estimation methods. In this study, we aimed to assess how each method performs using a range of scenarios with varying degrees of assumption compliance and violations. In each scenario, artificial datasets are created with with known population sizes, density patterns, detectability patterns, etc. to test the accuracy and precision of estimators.

## Simulation scenarios

### Initial perpendicular distance distribution

Perpendicular distance refers to the minimum distance to the transect line at which animals are detected. 3 different levels are considered: uniformly distributed, avoiding the line and attracted to the line.

```{r initial perp. dist. distribution}
par(mfrow=c(1,3))
xs <- seq(0,1,length=100)

# uniformly distributed
plot(xs, pi.const(x=xs,logphi=NA,w=1),
     type='l',xlab='Perp. distance, x',ylab=expression(pi(x)))

# avoiding the line
plot(xs, pi.chnorm(x=xs,logphi=c(0, -0.5),w=1),
     type='l',xlab='Perp. distance, x',ylab=expression(pi(x)))

# attracted to the line
plot(xs,pi.norm(x=xs,logphi=c(0, 1),w=1),
     type='l',xlab='Perp. distance, x',ylab=expression(pi(x)))

```

```{r distribution-plots, echo = F, fig.cap = "Potential Animal Distributions"}
par(mfrow = c(1,3))
const <- simpop2DLT(600,2000,pi.const, En = 400, fixed.n = T)
plot(const$x, const$y, xlab = "x", ylab = "y", main = "Uniformly Distributed")
abline(v = 0, col = 'red')
avoid <- simpop2DLT(600,2000,pi.chnorm, logphi = c(0,6), En = 400, fixed.n = T)
plot(avoid$x, avoid$y, xlab = "x", ylab = "y", main = "Avoiding Line")
abline(v = 0, col = 'red')
attract <- simpop2DLT(600,2000,pi.hnorm, logphi = 6.5, En = 400, fixed.n = T)
plot(attract$x, attract$y, xlab = "x", ylab = "y", main = "Attracted to Line")
abline(v = 0, col = 'red')
```

### Movement after first detection

For the mark recapture methods there are two detection occasions, which could be , for example, two observers on different decks of a boat or , as in the snow leopard prey data, two observers walking the transect at different times. Animal movement is not an issue for the first scenario as the animals move slowly in comparison to the boat, so will not move far enough to have different detection probabilities between the two observers. However, in our snow leopard prey example, there is 30 minutes between the first and second observer walking the transect so the animals could move significantly between the two observers. We consider two types of movement after the first detection: random movement and avoidant movement away from the transect. We based our simulation on Ibex movement data in Johansson *et al*. (2022), which shows that the distance moved follows roughly a log normal distribution with mean log(12) + 1.5 and standard deviation 1.5,

```{r movement, echo = F, fig.asp= 1.25, warning = F}
library(plotly)
par(mfrow = c(1,2))
sim.dat <- function(n, level){
  #browser()
  ## 1. object positions
  df <- data.frame(obs=rep(1:2, n),
                   x=NA, y=NA, size=NA, level=NA)
  
  df$x[df$obs==1] <- runif(n, -1600, 1600); df$y[df$obs==1] <- runif(n, 0, 600)
  df$size <- rep(sample(4:10, n, replace = TRUE), each=2)
  perp.dist <- abs(df$x[df$obs==1])
  
  
  if (level==1){
    angle <- rwrappedcauchy(n, mu = circular(0), rho = 0, control.circular=list(units="radian"))
    dist <- rlnorm(n,log(12) + 1.5,1.5)
    dist[dist > 750] <- 750
    df$x[df$obs==2] <- df$x[df$obs==1] + dist*cos(angle)
    df$y[df$obs==2] <- df$y[df$obs==1] + dist*sin(angle)/1000
    df$level <- rep("Random", 2*n)
    }else{
    nleft <- nrow(df[df$x <= 0 & df$obs==1, ])
    nright <- nrow(df[df$x > 0 & df$obs==1, ])
    
    angleleft <- rwrappedcauchy(nleft, mu=circular(pi), rho=0.9, control.circular=list(units="radian"))
    df$angle[df$x <= 1 & df$obs==1] <- as.numeric(angleleft)
    angleright <- rwrappedcauchy(nright, mu=circular(0), rho=0.9, control.circular=list(units="radian"))
    df$angle[df$x > 1 & df$obs==1] <- as.numeric(angleright)
    
    dist <- (max(abs(df$x[df$obs==1]))-abs(df$x[df$obs==1]))*runif(n, 0, 0.1)*2.5
    df$x[df$obs==2] <- df$x[df$obs==1] + dist * cos(df$angle[df$obs==1])
    df$y[df$obs==2] <- df$y[df$obs==1] + dist * sin(df$angle[df$obs==1])/1000
    df$level <- rep("Avoidance", 2*n)
    df[ , c("angle")] <- list(NULL)
  }
  
  
  ## 3. return
  return(df)
}

df1 <- sim.dat(50,1)
fig <- df1 %>%
  plot_ly(
    x = ~x,
    y = ~y,
    size = ~size,
    color = ~level,
    frame = ~obs,
    type = 'scatter',
    mode = 'markers')
fig
```

```{r movement-animations}
df2 <- sim.dat(50,2)
fig2 <- df2 %>%
  plot_ly(
    x = ~x,
    y = ~y,
    size = ~size,
    color = ~level,
    frame = ~obs,
    type = 'scatter',
    mode = 'markers')
fig2
```

### Imperfect Matching

Mark recapture methods also assume that the observers can perfectly identify which animals were seen by both observers and which animals were seen by just one observer. This becomes problematic for animals without unique identifying markings in surveys where they could move between detection occasions.

We simulated imperfect matching by setting any animals detected on the second occasion within 300m of an animal detected on the first animal were recorded as the same animal, taking the closest as the match if there were multiple within this range. Any animals further than 1000m were recorded as different, and the probability of matching animals within the range was generated using a inverse power function with parameters $\beta_1$ = 6, $\beta_2$ = 0.000005. (Thanks to the snow leopard prey team for suggesting these limits)

```{r imperfect-matching plot, echo = F}
x <- 0:1000
p <- p.approx(ys <- seq(0, 1300, length.out=100),x , ip0, b=c(6, 0.000005), what = "px")
plot(x,p,ylim = c(0,1), type = "l", xlab = "Distance", ylab = "Probability")
abline(v = 300)
```

## Simulation Results

For each of the 12 scenarios we calculated the bias and coverage probability of the 4 methods. Due to time constraints we only fitted a hazard-rate detection function with no adjustments for conventional distance sampling and only used the independent observer configuration with a hazard rate distance model for MRDS. This means the models for these methods may not be the best fit, and it could be possible to achieve a smaller bias or larger coverage probability. With more time we would fit multiple models to each set of simulated data and choose the best using AIC. We also only fit one 2D model, but as it was the model used the generate the data it should be the best model regardless. 

### Uniform Animal Distribution

With uniform animal distribution we expect conventional distance and 2D distance sampling to perform similarly, as all the assumptions for both methods are met. Our results show that they both have similar coverage probabilities, and whilst conventional distance may appear to be more biased, this is more likely a result of only fitting one model rather than performing model selection. As these methods involve walking the transect just once, they are not affected by movement between observers.

```{r Sc.1, message=FALSE, warning=FALSE, cache=TRUE, echo = F}
# Scenario 1
# Initial density: uniform + Movement: avoidance + Matching: perfect
#sc1 <- simulation(n=600, b=99, 0, 0, FALSE)
load("sc1.RData")
sc1.table <- kable(sc1.out <- result(sc1, n=600), col.names = c("Bias", "Coverage Probability"), caption = "Avoidance Movement")
```

```{r Sc.2, message=FALSE, warning=FALSE, cache=TRUE, echo = FALSE, fig.cap = "Uniform animal density, avoidance movement and imperfect matching"}
# Scenario 2
# Initial density: uniform + Movement: avoidance + Matching: imperfect
#sc2 <- simulation(n=600, b=99, 0, 0, TRUE)
load("sc2.RData")
sc2.table <- kable(sc2.out <- result(sc2, n=600), col.names = c("Bias", "Coverage Probability"), caption = "Avoidance Movement")
```

```{r Sc.3, message=FALSE, warning=FALSE, cache = TRUE, echo = F, fig.cap = "Uniform distribution and perfect matching"}
# Scenario 3
# Initial density: uniform + Movement: random + Matching: perfect
#sc3 <- simulation(n=600, b=99, 0, 1, FALSE)
load("sc3.RData")
sc3.table <- kable(sc3.out <- result(sc3, n=600), col.names = c("Bias", "Coverage Probability"), caption = "Random Movement")

kables(list(sc3.table, sc1.table))
```

Mark recapture performs poorly in this scenario and all the other scenarios as detectability declines with distance. This means there is unmodelled heterogeneity in the population, so it is negatively biased. MRDS is negatively biased with random animal movement as this violates the assumption that each animal has the same detection probability for each observer. It is less negatively biased with avoidance as second observer will see less animals than the first due to them now being further away. This results in a lower estimated detection probability and therefore a higher estimate.

```{r Sc.4, message=FALSE, warning=FALSE, cache = TRUE, echo = F, fig.cap = "Uniform Distribution and Imperfect Matching"}
# Scenario 4
# Initial density: uniform + Movement: random + Matching: imperfect
#sc4 <- simulation(n=600, b=99, 0, 1, TRUE)
load("sc4.RData")
sc4.table <- kable(sc4.out <- result(sc4, n=600),col.names = c("Bias", "Coverage Probability"), caption = "Random Movement")
kables(list(sc4.table, sc2.table), caption = "With Imperfect Matching")
```

After introducing imperfect matching, MRDS estimates seem to be less negatively biased. This is due to some individuals that were seen twice being mistakenly identified as two separate animals, leading to a lower estimate of detection probability and hence a higher estimate of abundance. Whilst it looks like MRDS should be the best estimator in the scenario with avoidance movement and imperfect matching, this is actually because effects of breaking multiple assumptions happen to balance out in this specific situation. This results in very variable estimates, as the variance of the $N\hat$s was `{r var(sc2[[3]]$N.hat[sc2[[3]]$N.hat < 3*600])/99}` for MRDS, compared to `{r var(sc2[[4]]$N.hat[sc2[[4]]$N.hat < 3*600])/99}` for 2D Distance. 
### Avoiding Transect
As expected, only 2D Distance is unbiased when the animals initially avoid the transect.
```{r Sc.5, message=FALSE, warning=FALSE, cache = TRUE, echo = F}
# Scenario 5
# Initial density: avoiding + Movement: avoidance + Matching: perfect
#sc5 <- simulation(n=1200, b=99, 1, 0, FALSE)
load("sc5.RData")
sc5[[3]] <- unname(apply(sc5[[3]], 1, as.list)[[1]])
index <- which(sapply(sc5[[3]], is.numeric))
sc5[[3]] <- data.frame(t(sapply(sc5[[3]][index], c)))
colnames(sc5[[3]]) <- c("N.hat", "lcl", "ucl")
sc5.table <- kable(sc5.out <- result(sc5, n=1200), col.names = c("Bias", "Coverage Probability"), caption = "Avoidance Movement")
```

```{r Sc.6, message=FALSE, warning=FALSE, cache = TRUE, echo = F}
# Scenario 6
# Initial density: avoiding + Movement: avoidance + Matching: imperfect
#sc6 <- simulation(n=1200, b=99, 1, 0, TRUE)
load("sc6.RData")
sc6[[3]] <- unname(apply(sc6[[3]], 1, as.list)[[1]])
index <- which(sapply(sc6[[3]], is.numeric))
sc6[[3]] <- data.frame(t(sapply(sc6[[3]][index], c)))
colnames(sc6[[3]]) <- c("N.hat", "lcl", "ucl")
sc6.table <- kable(sc6.out <- result(sc6, n=1200), col.names = c("Bias", "Coverage Probability"), caption = "Avoidance Movement")
```

```{r Sc.7, message=FALSE, warning=FALSE, cache = TRUE, echo = F,fig.cap = "Intially avoidant with perfect matching"}
# Scenario 7
# Initial density: avoiding + Movement: random + Matching: perfect
#sc7 <- simulation(n=1200, b=99, 1, 1, FALSE)
load("sc7.RData")
sc7[[3]] <- unname(apply(sc7[[3]], 1, as.list)[[1]])
index <- which(sapply(sc7[[3]], is.numeric))
sc7[[3]] <- data.frame(t(sapply(sc7[[3]][index], c)))
colnames(sc7[[3]]) <- c("N.hat", "lcl", "ucl")
sc7.table <- kable(sc7.out <- result(sc7, n=1200), col.names = c("Bias", "Coverage Probability"), caption = "Random Movement")
kables(list(sc7.table,sc5.table))
```
Conventional distance and MRDS are both negatively biased as the fitted detection function decays less quickly than the true detection function to account for the large numbers of detections far away from the transect. However, as these detections are a result of more animals being far from the transect rather than a high detection probability, the models overestimate the detection probability and so underestimate the abundance.
```{r avoidance-df-hist, echo = F, cache = TRUE, fig.cap = "Fitted detection function vs True detection function"}
exdata <- sim.data(1200,1,0)
exdata <- exdata[exdata$obs == 1 & exdata$detect == 1,]
n <- length(exdata$x)
new_df1 <- data.frame(Region.Label = rep(1, n), Area = rep(2*2000*600000, n),Sample.Label = rep(1, n), Effort = rep(600000, n),distance = abs(exdata$x))
df.ds <- ds(new_df1, truncation=1600, transect="line", key="hr", order=0, monotonicity = "none")
truedetect <- function(x){
  return(p.approx(ys <- seq(0,1700,100),x,ip0,b=c(4.9, 0.036), what = "px"))
}

plot(df.ds)
curve(truedetect, 0,1600,col = "red", add = T)
legend("topleft", legend = c("Fitted", "True"),lty = 1, col = c("black", "red"))
```
```{r Sc.8, message=FALSE, warning=FALSE, cache = TRUE, fig.cap = "Intially avoidant with imperfect matching", echo = FALSE}
# Scenario 8
# Initial density: avoiding + Movement: random + Matching: imperfect
#sc8 <- simulation(n=1200, b=99, 1, 1, TRUE)
load("sc8.RData")
sc8.table <- kable(sc8.out <- result(sc8, n=1200), col.names = c("Bias", "Coverage Probability"), caption = "Random Movement")
kables(list(sc8.table,sc6.table), caption = "With Imperfect Matching")
```
As before, all the methods except 2D distance sampling are negatively biased. The imperfect matching does make the MRDS estimates slightly bigger, but not enough to counteract the negative bias from the non uniform distribution. 
### Attracted to Transect
As with the avoidance case, we expect only 2D Distance to be unbiased when animals are initially attracted to the line.
```{r Sc.9, message=FALSE, warning=FALSE, cache = TRUE, echo = FALSE}
# Scenario 9
# Initial density: attracted + Movement: avoidance + Matching: perfect
#sc9 <- simulation(n=400, b=99, 2, 0, FALSE)
load("sc9.RData")
sc9.table <- kable(sc9.out <- result(sc9, n=400), col.names = c("Bias", "Coverage Probability"), caption = "Avoidant Movement")
```

```{r Sc.10, message=FALSE, warning=FALSE, cache = TRUE, echo = FALSE}
# Scenario 10
# Initial density: attracted + Movement: avoidance + Matching: imperfect
#sc10 <- simulation(n=400, b=99, 2, 0, TRUE)
load("sc10.RData")
sc10.table <- kable(sc10.out <- result(sc10, n=400), col.names = c("Bias", "Coverage Probability"), caption = "Avoidant Movement")
```

```{r Sc.11, message=FALSE, warning=FALSE, cache = TRUE, echo = FALSE, fig.cap = "Initially attracted to the line with perfect matching"}
# Scenario 11
# Initial density: attracted + Movement: random + Matching: perfect
load("sc11.Rdata")
sc11.table <- kable(sc11, col.names = c("Bias", "Coverage Probability"), caption = "Random Movement")
kables(list(sc11.table, sc9.table))
```
Conventional distance and MRDS are positively biased this time, as the fitted detection functions now decay quicker than the true function. This gives a lower detection probability and therefore a higher estimate. 
```{r Sc.12, message=FALSE, warning=FALSE, cache = TRUE, echo = FALSE}
# Scenario 12
# Initial density: attracted + Movement: random + Matching: imperfect
#sc12 <- simulation(n=400, b=99, 2, 1, TRUE)
load("sc12.Rdata")
sc12.table <- kable(sc12, col.names = c("Bias", "Coverage Probability"), caption = "Random Movement")
kables(list(sc12.table,sc10.table), caption = "With Imperfect Matching")
```

## Further Reading

Johansson, Ö., Mishra, C., Chapron, G., Samelius, G., Lkhagvajav, P., McCarthy, T. and Low, M. (2022). Seasonal variation in daily activity patterns of snow leopards and their prey. Scientific Reports, [online] 12(1), p.21681. <doi:https://doi.org/10.1038/s41598-022-26358-w>.

<!--chapter:end:Simulation.Rmd-->

#Real Data
```{r loading, include = F}
b = c(4.89553757, 0.03561984); logphi = c(6.61348904, 4.84269089)
w = 1600; ystart = 1700
```
We will now use these methods to analyse the real snow leopard prey data. The observers surveyed 60 transects in 10 blocks twice, with 30 minutes between the first and second observer starting the survey. The observers had limited rangefinders so only the first observer recorded the radial distance to the group, the bearing of the path and the bearing of the group they saw. This means we cannot use mrds to analyse this data as there are no distances for the second observer. There were 2 species included in the survey: ibex and argali. They saw 242 groups in total, and 193 of them have distance data.


## Mark Recapture
```{r chapman, include = FALSE}
chapman <- function(Gobi){
  S1 <- sum(Gobi$Obs1)
  S2 <- sum(Gobi$Obs2)
  B <- sum(Gobi$Obs1[Gobi$Obs2 == 1])
  Ngroups <- (S1+1)*(S2+ 1)/(B+1) - 1
  varNhat <- (S1+1)*(S2+ 1)*(S1-B)*(S2-B)/((B+2)*(B+1)**2)
  d <- exp(1.96*sqrt(log(1 + varNhat/Ngroups**2)))
  ci <- c(Ngroups/d, Ngroups*d)
  return(c(Ngroups, ci))
}
combined <- chapman(Gobi)
ibex.cm <- chapman(Gobi[Gobi$Sightings == 'ibex',])
argali.cm <- chapman(Gobi[Gobi$Sightings == 'argali',])
```
We start by using the Chapman estimator to estimate the total number of groups. This gives us an estimate of `r round(combined[1])` with a 95% confidence interval of `r combined[2:3]`. Separating the data by species we estimate there are `r round(ibex.cm[1])` (`r ibex.cm[2:3]`) ibex groups and `r round(argali.cm[1])` (`r argali.cm[2:3]`) argali groups. 
From our previous simulations we expect this to be negatively biased, as there is unmodelled heterogeneity in the population from detectability decreasing with distance. The estimates for the individual species are probably more reliable as it accounts for any difference in detectability between the two species. 
## Conventional Distance Sampling
We now turn to CDS. Upon closer inspection, many detection distances (both perpendicular and forward) appeared to be rounded to zero, likely as a result of the bearings being rounded to the nearest 5 degrees. To prevent this from impacting the model fit we simply added a small random number to each zero observation. We only use the jittered perpendicular distances for conventional distance sampling, but we will use the jittered forward distances in the 2D section. 
```{r perp-distance-histograms, fig.cap = "Histograms of perpendicular distances"}
hist(CDSData$distance, main = "Perpendicular Distance", xlab = "Distance")
```
We decided to truncate the data at 1600m, which excluded one outlier at 1820m. We then fitted a series of models using both half normal and hazard rate detection functions to the combined data set and to each species individually. We included size, block and observer (and species in the combined model) as covariates, and chose the best model using AIC. (Full analysis can be found in the _CDS analysis file.) 

```{r fit-CDS, include = F, warning = F}
hr_block <- ds(CDSdf, truncation = w, formula = ~Region.Label, key = "hr")
hr_ibex_block <- ds(ibexdf, truncation = w, formula = ~Region.Label, key = "hr")
hr_argali_block <- ds(argalidf, truncation = w, formula = ~Region.Label, key = "hr")
total.summary <- summary(hr_block)
ibex.summary <- summary(hr_ibex_block)
argali.summary <- summary(hr_argali_block)
```
The best fitting model according to AIC involved fitting separate hazard rate functions with block as a covariate to the ibex and argali data sets. However, the argali detection function has a large spike at zero, which is not realistic.  
```{r plot-separate species, echo = F, fig.cap= "Detection function and QQ-plots for ibex and argali models"}
par(mfrow = c(2,2))
plot(hr_ibex_block, main = "Ibex")
gofi <- gof_ds(hr_ibex_block)
plot(hr_argali_block, main = "Argali")
gofa <- gof_ds(hr_argali_block)
```
Therefore, we choose the combined model as our best model, as the AIC was only slightly higher (`r hr_block$ddf$criterion` vs `r hr_ibex_block$ddf$criterion + hr_argali_block$ddf$criterion`) and it doesn't have the spike at zero. 
```{r plot-combined, echo = F, fig.cap = "Detection function and QQ-plots for combined model"}
par(mfrow = c(1,2))
plot(hr_block)
gof <- gof_ds(hr_block)
```
```{r CDS-ci, include = F, warning = F}
CDSN <- total.summary$ds$Nhat
CDSci <- total.summary$ds$Nhat + c(-1,1)*1.96*total.summary$ds$Nhat.se
ibexN <- ibex.summary$ds$Nhat
ibexci <- ibex.summary$ds$Nhat + c(-1,1)*1.96*ibex.summary$ds$Nhat.se
argN <- argali.summary$ds$Nhat
argci <- argali.summary$ds$Nhat + c(-1,1)*1.96*argali.summary$ds$Nhat.se
```
This gives an estimate of `r round(CDSN)` total groups with a 95% confidence interval of `r CDSci`. This is much higher than the MCR estimate, but may be biased if the animal distribution is not uniform. 
## 2D Distance Sampling

We will now use 2D distance sampling to investigate if the animals are uniformly distributed. 61 of the detected groups were behind the observers so did not have a valid "forward" distance. This leaves 132 usable observations.
```{ forward-hist, echo = F}
hist(DistData$forward, main = "Forward Distance", xlab = "Distance (m)")
```

```{r fit-model, include = FALSE, warning=FALSE, cache = TRUE}
combined.ip0.hnorm <- LT2D.fit(DataFrameInput = jitterdf,
                            hr = 'ip0',
                            b = c(5,0.04),
                            ystart = ystart,      
                            pi.x = 'pi.hnorm',   
                            logphi = 6,
                            w = w,
                            hessian = TRUE)
ibex.ip0.hnorm <- LT2D.fit(DataFrameInput = ibexjitter, 
                            hr = 'ip0',
                            b = c(5,1),
                            ystart = ystart,      
                            pi.x = 'pi.hnorm',   
                            logphi = 5,
                            w = w,
                            hessian = TRUE)
argali.ip0 <- LT2D.fit(DataFrameInput = argalijitter,
                            hr = 'ip0',
                            b = c(4.86,0.03),
                            ystart = ystart,      
                            pi.x = 'pi.const',   
                            w = w,
                            hessian = TRUE)

total.N <- round(combined.ip0.hnorm$ests[nrow(combined.ip0.hnorm$ests),8])
total.ibex <- round(ibex.ip0.hnorm$ests[nrow(ibex.ip0.hnorm$ests),8])
total.argali <- round(argali.ip0$ests[nrow(argali.ip0$ests),8])
#not interested in individuals currently, keeping code in case we want it
#indivs.N <- round(combined.ip0.hnorm$ests[nrow(combined.ip0.hnorm$ests),,ncol(combined.ip0.hnorm$ests)])
#indivs.ibex <- round(ibex.ip0.hnorm$ests[nrow(ibex.ip0.hnorm$ests),ncol(ibex.ip0.hnorm$ests)])
#indivs.argali <- round(argali.ip0$ests[nrow(argali.ip0$ests),,ncol(argali.ip0$ests)])
#boot <- LT2D.bootstrap(combined.ip0.hnorm, r = 999, alpha = 0.05)
#ibexboot <- LT2D.bootstrap(ibex.ip0.hnorm, r = 999, alpha = 0.05)
#argaliboot <- LT2D.bootstrap(argali.ip0, r = 999, alpha = 0.05)
```
```{r group-ci, include=FALSE, warning=FALSE, cache = TRUE}
comb.groupdf <- jitterdf
comb.groupdf$size <- rep(1, length(comb.groupdf$size))
comb.group <- LT2D.fit(DataFrameInput = comb.groupdf,
                            hr = 'ip0',
                            b = c(5,0.04),
                            ystart = ystart,      
                            pi.x = 'pi.hnorm',   
                            logphi = 6,
                            w = w,
                            hessian = TRUE)
groupboot <- LT2D.bootstrap(comb.group, r = 999, alpha = 0.05)
groupci <- groupboot$ci
ibex.groupdf <- ibexjitter
ibex.groupdf$size <- rep(1, length(ibex.groupdf$size))
ibex.group <- LT2D.fit(DataFrameInput = ibex.groupdf,
                            hr = 'ip0',
                            b = c(5,0.04),
                            ystart = ystart,      
                            pi.x = 'pi.hnorm',   
                            logphi = 6,
                            w = w,
                            hessian = TRUE)
ibboot <- LT2D.bootstrap(ibex.group, r = 999, alpha = 0.05)
ibci <- ibboot$ci

argali.groupdf <- argalijitter
argali.groupdf$size <- rep(1, length(argali.groupdf$size))
argali.group <- LT2D.fit(DataFrameInput = argali.groupdf,
                            hr = 'ip0',
                            b = c(5,0.04),
                            ystart = ystart,      
                            pi.x = 'pi.hnorm',   
                            logphi = 6,
                            w = w,
                            hessian = TRUE)
argboot <- LT2D.bootstrap(argali.group, r = 999, alpha = 0.05)
argbootci <- argboot$ci
```

Our best fitting model used the 2-parameter inverse power hazard detection function and a half normal distribution for the animal density. All of the best fitting models used a half normal animal distribution, which implies that the animals are attracted to the line rather than avoiding it as initially thought. This could be due to the non random line placement, as the observers travel along valleys or ridges that are easier to walk along so the animals could also favour the easier terrain.

```{r real-results-plot,echo = F, fig.cap = "Detection and distribution functions for best model (h1 and normal)", cache = T}
par(mfrow = c(2,2))
plot(combined.ip0.hnorm)
test.results <- gof.LT2D(combined.ip0.hnorm, plot = T)
```

We tried fitting different models to each species in the survey, but this had a higher AIC than the combined model (`r ibex.ip0.hnorm$fit$AIC + argali.ip0$fit$AIC` vs `r combined.ip0.hnorm$fit$AIC` for combined model). Interestingly, the argali appear to be uniformly distributed across the area whereas the ibex exhibit line attraction. However, there are only 39 argali groups with valid distances so further investigation is needed before drawing any conclusions. With more time we would fit a model that had species as a covariate.

The best combined model estimates there are `r total.N` groups in total.
```{r estimate-by-block, echo = F, cache = T}
ests <- combined.ip0.hnorm$ests[,c(1,2,4,6,7:11)]
rownames(ests) <- NULL
kable(ests, col.names = c("Stratum", "Groups Seen", "Total Transect Length ($km$)", "Stratum Area ($m^2$)", "Estimated Group Denisty", "Number of Groups", "Mean Size", "Individual Density", "Abundance Estimate" ), escape = FALSE)
```

## Summary
The 2D distance analysis suggests that the animals are attracted to the line. This would make the conventional distance estimate positively biased, and so it is reasonable that the 2D estimate would be lower. We would expect the mark recapture estimate to be negatively biased due to the declining detectability with distance, but it is higher. This is likely due to imperfect matching in the data, so we recommend 2D Distance sampling as the most reliable estimate, as it is not impacted by imperfect matching or non uniform animal distribution. 

```{r tables, echo = F, cache = T}
combinedcis <- data.frame( "N" = c(round(total.N), round(CDSN), round(combined[1])), "L" = c(groupci[1], CDSci[1], combined[2]), "U" = c(groupci[2], CDSci[2], combined[3]), row.names = c("2D Distance", "Conventional Distance", "Chapman")) 
combtab <- kable(combinedcis, col.names = c("Point Estimate", "95% Confidence", "Interval"), caption = "Combined")

ibexcis <- data.frame( "N" = c(round(total.ibex), round(ibexN), round(ibex.cm[1])), "L" = c(ibci[1], ibexci[1], ibex.cm[2]), "U" = c(ibci[2], ibexci[2], ibex.cm[3]), row.names = c("2D Distance", "Conventional Distance", "Chapman"))
ibtab <- kable(ibexcis, col.names = c("Point Estimate", "95% Confidence", "Interval"),  caption = "Ibex")
argalicis <- data.frame( "N" = c(round(total.argali), round(argN), round(argali.cm[1])), "L" = c(argbootci[1], argci[1], argali.cm[2]), "U" = c(argbootci[2], argci[2], argali.cm[3]), row.names = c("2D Distance", "Conventional Distance", "Chapman"))
argtab <- kable(argalicis, col.names = c("Point Estimate", "95% Confidence", "Interval"), caption = "Argali")
kables(list(combtab, ibtab, argtab))
```
Whilst the combined model was the best fit for the data, we have included our separate estimates for each species as they may be more useful in practice. 

<!--chapter:end:07-Real-Data.Rmd-->

