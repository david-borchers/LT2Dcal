---
title: "A Minimal Book Example"
author: "John Doe"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
# url: your book url like https://bookdown.org/yihui/bookdown
# cover-image: path to the social sharing image like images/cover.jpg
description: |
  This is a minimal example of using the bookdown package to write a book.
  The HTML output format for this example is bookdown::gitbook,
  set in the _output.yml file.
link-citations: yes
github-repo: rstudio/bookdown-demo
---

# About

This is a *sample* book written in **Markdown**. You can use anything that Pandoc's Markdown supports; for example, a math equation $a^2 + b^2 = c^2$.

## Usage

Each **bookdown** chapter is an .Rmd file, and each .Rmd file can contain one (and only one) chapter. A chapter *must* start with a first-level heading: `# A good chapter`, and can contain one (and only one) first-level heading.

Use second-level and higher headings within chapters like: `## A short section` or `### An even shorter section`.

The `index.Rmd` file is required, and is also your first book chapter. It will be the homepage when you render the book.

## Render book

You can render the HTML version of this example book without changing anything:

1.  Find the **Build** pane in the RStudio IDE, and

2.  Click on **Build Book**, then select your output format, or select "All formats" if you'd like to use multiple formats from the same book source files.

Or build the book from the R console:

```{r, eval=FALSE}
bookdown::render_book()
```

To render this example to PDF as a `bookdown::pdf_book`, you'll need to install XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): <https://yihui.org/tinytex/>.

## Preview book

As you work, you may start a local server to live preview this HTML book. This preview will update as you edit the book when you save individual .Rmd files. You can start the server in a work session by using the RStudio add-in "Preview book", or from the R console:

```{r eval=FALSE}
bookdown::serve_book()
```

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

# 1. Hello bookdown

All chapters start with a first-level heading followed by your chapter title, like the line above. There should be only one first-level heading (`#`) per .Rmd file.

## A section

All chapter sections start with a second-level (`##`) or higher heading followed by your section title, like the sections above and below here. You can have as many as you want within a chapter.

### An unnumbered section {.unnumbered}

Chapters and sections are numbered by default. To un-number a heading, add a `{.unnumbered}` or the shorter `{-}` at the end of the heading, like in this section.

# 2. Cross-references {#cross}

Cross-references make it easier for your readers to find and link to elements in your book.

## Chapters and sub-chapters

There are two steps to cross-reference any heading:

1.  Label the heading: `# Hello world {#nice-label}`.
    -   Leave the label off if you like the automated heading generated based on your heading title: for example, `# Hello world` = `# Hello world {#hello-world}`.
    -   To label an un-numbered heading, use: `# Hello world {-#nice-label}` or `{# Hello world .unnumbered}`.
2.  Next, reference the labeled heading anywhere in the text using `\@ref(nice-label)`; for example, please see Chapter \@ref(cross).
    -   If you prefer text as the link instead of a numbered reference use: [any text you want can go here](#cross).

## Captioned figures and tables

Figures and tables *with captions* can also be cross-referenced from elsewhere in your book using `\@ref(fig:chunk-label)` and `\@ref(tab:chunk-label)`, respectively.

See Figure \@ref(fig:nice-fig).

```{r nice-fig, fig.cap='Here is a nice figure!', out.width='80%', fig.asp=.75, fig.align='center', fig.alt='Plot with connected points showing that vapor pressure of mercury increases exponentially as temperature increases.'} par(mar = c(4, 4, .1, .1)) plot(pressure, type = 'b', pch = 19)}
```

Don't miss Table \@ref(tab:nice-tab).

```{r nice-tab, tidy=FALSE} knitr::kable(   head(pressure, 10), caption = 'Here is a nice table!',   booktabs = TRUE )}
```

# 3. Parts

You can add parts to organize one or more book chapters together. Parts can be inserted at the top of an .Rmd file, before the first-level chapter heading in that same file.

Add a numbered part: `# (PART) Act one {-}` (followed by `# A chapter`)

Add an unnumbered part: `# (PART\*) Act one {-}` (followed by `# A chapter`)

Add an appendix as a special kind of un-numbered part: `# (APPENDIX) Other stuff {-}` (followed by `# A chapter`). Chapters in an appendix are prepended with letters instead of numbers.

# 4. Footnotes and citations

## Footnotes

Footnotes are put inside the square brackets after a caret `^[]`. Like this one [^index-1].

[^index-1]: This is a footnote.

## Citations

Reference items in your bibliography file(s) using `@key`.

For example, we are using the **bookdown** package [@R-bookdown] (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and **knitr** [@xie2015] (this citation was added manually in an external file book.bib). Note that the `.bib` files need to be listed in the index.Rmd with the YAML `bibliography` key.

The RStudio Visual Markdown Editor can also make it easier to insert citations: <https://rstudio.github.io/visual-markdown-editing/#/citations>

# 5. Blocks

## Equations

Here is an equation.

```{=tex}
\begin{equation}    f\left(k\right) = \binom{n}{k} p^k\left(1-p\right)^{n-k}   (\#eq:binom) \end{equation}
```
You may refer to using `\@ref(eq:binom)`, like see Equation \@ref(eq:binom).

## Theorems and proofs

Labeled theorems can be referenced in text using `\@ref(thm:tri)`, for example, check out this smart theorem \@ref(thm:tri).

::: {#tri .theorem}
For a right triangle, if $c$ denotes the *length* of the hypotenuse and $a$ and $b$ denote the lengths of the **other** two sides, we have $$a^2 + b^2 = c^2$$
:::

Read more here <https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html>.

## Callout blocks

The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: <https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html>

# 6. Sharing your book

## Publishing

HTML books can be published online, see: <https://bookdown.org/yihui/bookdown/publishing.html>

## 404 pages

By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you'd like to customize your 404 page instead of using the default, you may add either a `_404.Rmd` or `_404.md` file to your project root and use code and/or Markdown syntax.

## Metadata for sharing

Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the `index.Rmd` YAML. To setup, set the `url` for your book and the path to your `cover-image` file. Your book's `title` and `description` are also used.

This `gitbook` uses the same social sharing data across all chapters in your book- all links shared will look the same.

Specify your book's source repository on GitHub using the `edit` key under the configuration options in the `_output.yml` file, which allows users to suggest an edit by linking to a chapter's source file.

Read more about the features of this output format here:

<https://pkgs.rstudio.com/bookdown/reference/gitbook.html>

Or use:

```{r eval=FALSE} ?bookdown::gitbook}
```

# 7.References

`r if (knitr::is_html_output()) ' # References {-} '`

<!--chapter:end:index.Rmd-->

# Introduction

Accurate estimation of animal abundance is a fundamental aspect of ecological research and wildlife conservation. Since total enumeration are rarely possible for natural populations of animals, robust estimation methods have to be used. Commonly used approaches for estimating animal abundance include mark-recapture, distance sampling, and mark-recapture distance sampling (MRDS). Each of these methods relies on different principles and assumptions to estimate population sizes.

The mark-recapture method is based on capturing and marking individuals, followed by subsequent recapture efforts to estimate the total population size. Distance sampling, on the other hand, involves estimating the detection probability of individuals at different distances from the observer, allowing for the extrapolation of population size based on detection functions. MRDS is an extension that accounts for both the detection probabilities of individuals at different distances and the potential for recapture of marked individuals, providing more precise estimates, even when assumptions of closed populations and uniform detection probabilities are not fully met.

However, the accuracy and reliability of these estimation methods depend heavily on how well their underlying assumptions are met. Assumptions such as closed population, random sampling, and homogeneous detection probabilities play a crucial role in determining the performance of the models. When these assumptions are violated, the estimates obtained from the methods can be biased and lead to misleading conclusions.

In this study, we systematically tested the three methods using a range of scenarios with varying degrees of assumption compliance and violations. By simulating populations with known abundance and detectability patterns, we aimed to assess how each method performed under different conditions. In the following sections of this report, we will present the methodology of our simulation study and the results obtained from the simulations.

<!--chapter:end:01-intro.Rmd-->

# Mark-recapture {#cross}

Mark-recapture is a powerful technique used in ecology and wildlife biology to estimate the population size of a specific animal or species within a given area. This method is based on the concept of sampling, marking, and then recapturing individuals from the target population. By utilizing this approach, researchers can extrapolate the population size and gain valuable insights into population dynamics, species abundance, and conservation efforts.

The fundamental principle behind mark-recapture lies in the idea that the probability of capturing an individual within the population is the same for each capture event. Once an individual is captured, it is marked in some way, making it distinguishable from other members of the population. The marked individuals are then released back into the wild, allowing them to mix freely with the unmarked individuals. Subsequently, during the recapture phase, researchers perform another sampling effort, capturing a new group of individuals from the population. The proportion of marked individuals in the recaptured sample allows scientists to estimate the total population size based on the assumption of a closed population.

In this chapter, we explore the principles and applications of mark-recapture methods, focusing on the Lincoln-Peterson MR estimator in closed populations and the importance of simulation studies to evaluate method performance.

## 2.1 Closed populations

The Lincoln-Peterson MR estimator is one of the most classic and widely used methods for estimating the population size of closed populations. Proposed independently by Peterson in the 1890s and by Lincoln in the 1920s, this estimator relies on two sampling events: the initial capture, where a subset of the population is marked, and the subsequent recapture, where the marked individuals are identified among the newly captured individuals.

The Chapman mark-recapture estimator is a modified version of the traditional Lincoln-Peterson estimator with less bias and is less affected by zeros.

::: {#tri .theorem}
**Chapman MR estimator (1951)** $$\hat{N}_{CPM} = \frac{(n_{1} + 1)(n_{2} + 1)}{m_{2}+1}-1$$

where:

-   $\hat{N}_{CPM}$ is the estimated population size.

-   $n_{1}$ is the number of individuals captured and marked in the first occasion.

-   $n_{2}$ is the number of marked individuals recaptured in the second occasion.

-   $m_{2}$ is the number of recaptured individuals that were already marked in the first occasion.
:::

The accuracy of this estimate relies on a number of assumptions being met.

| **Assumption 1.** The population is closed to additions and deletions;

In other words, no individuals are added to or removed from the population through birth, death, immigration, or emigration during the study period. An exception is when there are equal proportions of additions or deletions for marked and unmarked individuals during the sampling period. In cases where significant movements occur, potential bias might need to be introduced to the results or more advanced models might be needed to account for population dynamics.

| **Assumption 2.** All animals are equally likely to be captured in each sample;

Sometimes after initial capture, animals may learn to avoid the traps or area where the capture occurred, causing them to be captured less frequently ("trap shy"). The opposite ("trap happy") may also occur, making them more likely to be captured. Individuals may also inherently different capture probabilities, and if ignored, the resulting abundance estimates are likely to be negatively biased.

| **Assumption 3.** Marks are not lost and not overlooked by the observer

It is possible that marks may fade, fall off, or be lost over time, making individuals indistinguishable from unmarked ones during recapture events. Ensuring durable and effective marking techniques is essential to maintain the integrity of the mark-recapture process and achieve unbiased estimates.

## 2.2 Simulation study

Simulation studies have become indispensable in ecology and conservation research, providing a controlled and repeatable approach to evaluate the performance of estimation methods. In this section, we will present the results of a simulation study that aims to evaluate the performance of the Lincoln-Peterson MR estimator in closed populations. We will create artificial datasets with with known population sizes, detectability patterns to assess the accuracy and precision of estimators under different scenarios.

For each scenario we simulate 999 surveys, with each survey having a simulated sample size $N$ = 500.

#### Scenario 1: When the underlying assumptions are met

We first looked into the performance of mark-recapture estimator when all the above assumptions are met. Specifically, we will create artificial datasets to mimic a closed population, equal probability of detection of marked and unmarked individuals ($p$ = 0.4), and random sampling. For each replication, we will compare the estimated population size to the true population size ($N$ = 500). We then calculate the mean estimate and the variance of the estimates across replications and thus check if true population size is within the confidence interval of the estimates. The result below shows that Chapman estimator of abundance is nearly unbiased, i.e. the mean percentage relative bias is very close to 0.

```{r MR1}
library(circular)
library(Distance)

sim.mr <- function(n, equal.p, param){
  #browser()
  ## 1. generate n uniform points 
  df <- data.frame(id=rep(1:n, each = 2), obs=rep(1:2, n),
                   x=NA, y=NA, distance=NA, detect=NA)
  
  df$x[df$obs==1] <- runif(n, 0, 2)
  df$y[df$obs==1] <- runif(n, 0, 2)
  df$distance[df$obs==1] <- df$x[df$obs==1] - 1
  
  angle <- rwrappedcauchy(n, mu = circular(0),rho = 0)
  distance <- abs(rnorm(n, 0.1, 0.1))
  df$x[df$obs==2] <- as.numeric(df$x[df$obs==1] + distance*cos(angle))
  df$y[df$obs==2] <- as.numeric(df$y[df$obs==1] + distance*sin(angle))
  
  #df$x[df$obs==2] <- runif(n, 0, 2)
  #df$y[df$obs==2] <- runif(n, 0, 2)
  df$distance[df$obs==2] <- df$x[df$obs==2] - 1
  
  
  ## 2. detection probability
  if (equal.p == TRUE){
    p1 <- p2 <- param
  }else{
    p1 <- exp(-abs(df$distance[df$obs==1])^2/(2*param^2))
    p2 <- exp(-abs(df$distance[df$obs==2])^2/(2*param^2))
  }
  
  
  ## 3. Mark-Recapture
  df$detect[df$obs==1] <- rbinom(n, 1, p1)  # first occasion
  df$detect[df$obs==2] <- rbinom(n, 1, p2)  # second occasion
  
  
  ## 4. return
  S1 <- nrow(df[df$obs==1 & df$detect==1, ])  # caught by first occasion
  S2 <- nrow(df[df$obs==2 & df$detect==1, ])  # caught by second occasion
  B <- df$detect[df$obs==1]==1 & df$detect[df$obs==2]==1  
  B <- length(B[B==TRUE])  # caught by both occasions
  N.hat <- (S1+1)*(S2+1)/(B+1)-1  # abundance estimate
  return(N.hat)
}

boot.mr <- function(n, equal.p, param){
  input <- rep(n, 999)
  est.N <- unlist(lapply(input, sim.mr, equal.p, param))
  return(est.N)
}
```

```{r}
est.N <- boot.mr(500, TRUE, 0.4)  # bootstrap estimates
ci <- mean(est.N) + c(-1, 1)*1.96*sqrt(var(est.N)/999)  # confidence interval
bias <- mean((est.N-500)/500*100)  # mean percentage relative bias
ci; bias
```

#### Scenario 2: When inherent capture probabilities are different

In this scenario, we aim to examine the impact of deviations from equal detectability assumption on the accuracy and bias of mark-recapture method. We make probability of detection falls off with distance from the transect line following half-normal distribution in both occasion. Different half-normal parameters are fitted to investigate how they affect the estimate. As shown in the graph below, when detectability decreases more rapidly with increasing distance ($\sigma = 0.3$), the estimate are more negatively biased. In contrast, if there has less difference between detection probability on the transect and deetction probability on the truncation ($\sigma = 0.7$), then abundance estimate are less negatively biased.

```{r MR2}

plot1.1 <- function(n){
  #browser()
  par(mfrow=c(1,2))
  
  ## plot 1: half-normal
  x <- seq(0, 1, 0.01)
  y1 <- exp(-x^2/(2*0.3^2))
  y2 <- exp(-x^2/(2*0.5^2))
  y3 <- exp(-x^2/(2*0.7^2))
  plot(x, y1, main = "Half normal", xlab = "Distance", ylab = "Detection probability",
       type="l", lwd=1.5, col="red", xlim=c(0, 1))
  lines(x, y2, col="blue", lwd=1.5, lty=2)
  lines(x, y3, col="darkgreen", lwd=1.5, lty=3)
  legend(x = "topright", legend = c("sigma = 0.3", "sigma = 0.5", "sigma = 0.7"),  
         lty = c(1, 2, 3), col = c("red", "blue", "darkgreen"), lwd = 1.5, cex=0.5) 
  
  
  ## plot 2: bootstrap abundance estimates
  N1 <- boot.mr(n, FALSE, 0.3)
  N2 <- boot.mr(n, FALSE, 0.5)
  N3 <- boot.mr(n, FALSE, 0.7)
  plot(0.3, mean(N1), pch=7, col="red", xlim=c(0.2, 0.8), ylim=c(min(N1), n+10), xlab="sigma", ylab="estimates")
  title(main="Abundance estimates for different detetction functions, N = 500", cex.main=1)
  points(0.5, mean(N2), pch=7, col="blue")
  points(0.7, mean(N3), pch=7, col="darkgreen")
  abline(h=n, lwd=1.5)
  x <- seq(0.3, 0.7, 0.02)
  y <- NULL
  for (i in x){
    meanN <- mean(boot.mr(n, FALSE, i))
    y <- c(y, meanN)}
  lines(x, y, lty=3, lwd=1.5)
  legend(x = "bottomright", legend = c("sigma = 0.3", "sigma = 0.5", "sigma = 0.7"),  
         pch = c(7, 7, 7), col = c("red", "blue", "darkgreen"), cex=0.5) 
  
  
  ## table: 
  bias <- unlist(lapply(c(N1, N2, N3), FUN = function(x) mean((x-500)/500*100)))
  coverage <- NA
  
}
```

```{r}
# I may change the second plot to box plot
# or add a table presenting bias&coverage prob for each sigma
plot1.1(500)  # Chapman MR estimator, N
```

#### Limitations of mark-recapture

The validity and accuracy of mark-recapture method relies on critical assumptions. As shown in the simulation above, violation of equal capture probability assumption can lead to biased abundance estimates. Yet, the method has other limitations that may affect result reliability. Small sample size, for example, can lead to decreased precision, larger confidence intervals, and less informative results. Imperfect matching is another circumstance which cause bias in population size estimates. We will investigate more about mismatching case in the following chapters of mark-recapture distance sampling (MRDS) method.

<!--chapter:end:02-mark-recapture.Rmd-->

# Distance sampling

Distance sampling is another widely used method in ecological research or estimating animal abundance and density. Here we focus on conventional distance sampling, the fundamental distance sampling techniques among all.

## 3.1 Line transect sampling

Usually, observers travel along the transect lines that are strategically placed across the study area to ensure coverage of different habitats and representative sampling of the population. Upon detecting an object, they record the perpendicular distance from the line to the identified object. In some cases, additional information, such as the angle of detection or group size are also recorded for the purpose of multiple-covariate distance sampling (MCDS) analysis.

Detection function $g(x)$describes the probability of detecting an animal at different distances from the transect lines. A fundamental assumption is that all objects present on the line are detected, i.e. $g(0)=1$ ; however it is expected that objects become progressively more challenging to detect as their distance from the line increases, leading to a decrease in detection with increasing distance. Commonly used detection functions include uniform, half-normal and hazard rate. Example of adjustment terms include cosine, Hermite polynomial series and simple polynomial series.

```{r detection func}
detection <- function(){
  hn.sigma <- c(0.2, 0.3, 0.4)
  hr.sigma <- 0.3; hr.beta <- c(1, 2, 5)
  
  x <- seq(0, 1, 0.01)
  y.unif <- x/x
  y.hn1 <- exp(-x^2/(2*hn.sigma[1]^2)); y.hn2 <- exp(-x^2/(2*hn.sigma[2]^2)); y.hn3 <- exp(-x^2/(2*hn.sigma[3]^2))
  y.hr1 <- 1-exp(-(x/hr.sigma)^(-hr.beta[1])); y.hr2 <- 1-exp(-(x/hr.sigma)^(-hr.beta[2])); y.hr3 <- 1-exp(-(x/hr.sigma)^(-hr.beta[3]))
  
  par(mfrow=c(1,3))
  plot(x, y.unif, type="l", col="red", xlab="Distance", ylab="Detection probability", main="Uniform", ylim=c(0, 1))
  
  plot(x, y.hn1, type="l", lwd=1.5, col="red", xlab="Distance", ylab="Detection probability", main="Half-normal", ylim=c(0, 1))
  lines(x, y.hn2, col="darkgreen", lty=2, lwd=1.5)
  lines(x, y.hn3, col="steelblue", lty=3, lwd=1.5)
  legend(x = "topright", legend = c("sigma = 0.2", "sigma = 0.3", "sigma = 0.4"),  
         lty = c(1, 2, 3), col = c("red", "darkgreen", "steelblue"), lwd = 1.5, cex=0.5) 
  
  plot(x, y.hr1, type="l", lwd=1.5, col="red", xlab="Distance", ylab="Detection probability", main="Hazard rate (sigma = 0.3)", ylim=c(0, 1))
  lines(x, y.hr2, col="darkgreen", lty=2, lwd=1.5)
  lines(x, y.hr3, col="steelblue", lty=3, lwd=1.5)
  legend(x = "topright", legend = c("beta = 1", "beta = 2", "beta = 5"),  
         lty = c(1, 2, 3), col = c("red", "darkgreen", "steelblue"), lwd = 1.5, cex=0.5) 
  
}
```

```{r}
detection()  # plot detection functions
```

Once the detection function is fitted, the estimator can calculate animal density and thus abundance by accounting for the area surveyed and the proportion of animals detected at different distances. The obtained abundance estimates can be extrapolated to the entire study area if the survey design is representative of the entire habitat.

::: {#tri .theorem}
**Animal density** $D$ **is estimated by:** $$\hat{D} = \frac{n}{2wL\hat{P}_a}$$

$$\hat{P}_a = \frac{\int_{0}^{w}\hat{g}(x)dx}{w}$$

where:

-   $n$ is the number of animals detected.

-   $w$ is the half-width of the strip.

-   $L$ is the lengths of transect lines.

-   $\hat{P}_a$ is the probability that a randomly chosen animal within the surveyed area is detected.

-   $\hat{g}(x)$ is the estimate of detection function.
:::

## 3.2 Simulation study

In this section, we will present the results of a simulation study that aims to evaluate the performance of the conventional line transect sampling. We will create artificial datasets with with known population sizes, detectability patterns to assess the accuracy and precision of the method under different scenarios.

For each scenario we simulate 99 surveys, with each survey having a simulated sample size $N$ = 500.

#### Scenario 1: When the underlying assumptions are met

We investigate how well the method performs when $p(0) = 1$ assumption is met and animals are uniformly distributed. For each replication, we will compare the estimated abundance to the true population size ($N$ = 500). The detection function chosen is half-normal with $\sigma = 0.4$ . We then calculate the mean estimate and the variance of the estimates across replications and thus check if true population size is within the confidence interval of the estimates.

The result below shows that the abundance estimate is nearly unbiased, i.e. the mean percentage relative bias is very close to 0.

```{r simulated data DS, message=FALSE}
sim.data.ds <- function(n, sigma){
  #browser()
  ## 1. generate n uniform points 
  df <- data.frame(id=rep(1:n, each = 2), obs=rep(1:2, n),
                   x=NA, y=NA, distance=NA, detect=NA, angle=NA)
  df$x[df$obs==1] <- runif(n, 0, 2)
  df$y[df$obs==1] <- runif(n, 0, 2)
  df$distance[df$obs==1] <- df$x[df$obs==1] - 1
  
  ## 2. Points moving away from transect
  # moving angle & distance
  nleft <- nrow(df[df$x <= 1 & df$obs==1, ])
  nright <- nrow(df[df$x > 1 & df$obs==1, ])
  
  angleleft <- rwrappedcauchy(nleft, mu=circular(pi), rho=0.8, control.circular=list(units="radian"))
  df$angle[df$x <= 1 & df$obs==1] <- as.numeric(angleleft)
  angleright <- rwrappedcauchy(nright, mu=circular(0), rho=0.8, control.circular=list(units="radian"))
  df$angle[df$x > 1 & df$obs==1] <- as.numeric(angleright)
  
  dist <- (1-abs(df$distance[df$obs==1]))*runif(n, 0, 0.2)*3
  df$x[df$obs==2] <- df$x[df$obs==1] + dist * cos(df$angle[df$obs==1])
  df$y[df$obs==2] <- df$y[df$obs==1] + dist * sin(df$angle[df$obs==1])
  df$distance[df$obs==2] <- df$x[df$obs==2] - 1
  
  
  ## 3. detection probability, half-normal
  p1 <- exp(-abs(df$distance[df$obs==1])^2/(2*sigma^2))
  p2 <- exp(-abs(df$distance[df$obs==2])^2/(2*sigma^2))
  
  df$detect[df$obs==1] <- rbinom(n, 1, p1)  # first situation
  df$detect[df$obs==2] <- rbinom(n, 1, p2)  # second situation
  df$detect[abs(df$distance) > 1] <- 0  # truncation
  
  
  ## 4. return
  df[ , c("angle")] <- list(NULL)
  return(df)
}
```

```{r}
ds.analysis <- function(n, sigma, movement){
  #browser()
  df <- sim.data.ds(n, sigma)
  
  if (movement == TRUE){
    df1 <- subset(df, df$obs==2 & df$detect==1)
  }
  else{
    df1 <- subset(df, df$obs==1 & df$detect==1)
  }

  n <- nrow(df1)
  new_df1 <- data.frame(Region.Label = rep(1, n), Area = rep(4, n), 
                        Sample.Label = rep(1, n), Effort = rep(2, n),
                        distance = df1$distance)
  
  if (movement == TRUE){
    df.ds <- ds(new_df1, truncation=1, transect="line", key="hn", order=0, monotonicity = "none")
  }
  else{
    df.ds <- ds(new_df1, truncation=1, transect="line", key="hn", monotonicity = "none")
  }
  
  return(df.ds$ddf$Nhat)
}

boot.ds <- function(n, sigma, movement){
  input <- rep(n, 99)
  est.N <- unlist(lapply(input, ds.analysis, sigma, movement))
  return(est.N)
}
```

```{r message=FALSE, warning=FALSE}
est.N.mr <- boot.ds(500, 0.4, FALSE)  # bootstrap estimates
ci <- mean(est.N.mr) + c(-1, 1)*1.96*sqrt(var(est.N.mr)/99)  # confidence interval
bias <- mean((est.N.mr-500)/500*100)  # mean percentage relative bias
ci; bias
```

#### Scenario 2: When animals show responsive movement

Apart from assuming that objects on the transect line are certain to be detected, another model assumption of distance sampling is that objects are detected at their initial location. Here we aim to examine the validity of method when animals move in response to the observer (away from transect line in this case) before being detected. The detection function chosen is half-normal with $\sigma = 0.4$ . The result above shows that the abundance estimate is negatively unbiased with mean percentage relative bias being about 50%.

```{r}
ds.result <- function(n, sigma, movement){
  #browser()
  par(mfrow=c(1,2))
  
  ## plot 1: animal distribution
  df <- sim.data.ds(n, sigma)
  ddist <- density(df$distance[df$obs==2]+1)
  plot(ddist, main="Animal distribution after responsive movement", xlab="", ylab="")
  polygon(ddist, col="grey")
  
  
  ## plot 2: histogram of bootstrap abundance estimates
  est.N <- boot.ds(n, sigma, movement)
  hist(est.N, main=paste("Abudance estimates"), xlab=NULL, ylab = NULL, prob=TRUE)
  points(mean(est.N),0,pch=19,col="red")
  arrows(quantile(est.N, 0.025),0,quantile(est.N, 0.975),0,angle=90,code=3,col="red")
  
  return(est.N)
}
```

```{r ds responsive movement, message=FALSE, warning=FALSE}
est.N.ds <- ds.result(500, 0.4, TRUE)
```

```{r}
ci <- mean(est.N.ds) + c(-1, 1)*1.96*sqrt(var(est.N.ds)/99)  # confidence interval
bias <- mean((est.N.ds-500)/500*100)  # mean percentage relative bias
ci; bias
```

## Further Reading

Buckland, S.T., Rexstad, E.A., Marques, T.A. and Oedekoven, C.S. (2015). Distance Sampling: Methods and Applications. Springer International Publish, pp.99--103.

<!--chapter:end:03-parts.Rmd-->

# Mark Recapture Distance Sampling

```{r mrds-setup, include = FALSE}
#set up
source("code.R")
Nanimals = 200
hr_param = c(0.8,6) #parameters for detection function
match_limits = c(0.3,1)
match_param = c(0.45,5)
p0 = 0.8
```

## Introduction

Mark Recapture Distance Sampling (MRDS) combines the principles of mark-recapture and standard distance sampling. 2 observers each travel along the same transect and record the animals they see and the perpendicular distance. By including the capture history of each animal we have enough information to allow for non-zero detection probability on the line, but we lose the pooling robustness property, so unmodelled heterogeneity will cause biased estimates.

This model also assumes that the observers perfectly match which animals they both saw and which ones only one observer saw. If the animals don't have uniquely identifying features and there is any kind of animal movement between surveys then this assumption will not hold.

## Simulation - p(0) \< 1 and animal movement

### Methods

To test the mrds estimator, we simulated `r Nanimals` animals with a uniform distribution across the study area and simulated an observer detecting animals with a hazard rate detection function with sigma = `r hr_param[1]`, beta = `r hr_param[2]`, scaled by 0.8 to see the affect of p(0) \< 1. We then had the animals move away in response to the observer with three levels of avoidance, and simulated the second observer detecting the animals in their new positions with the same detection function as the first observer.

```{r mrds-avoidance,echo = FALSE, out.width='50%', fig.asp=1.25, fig.margin = TRUE, fig.cap='Demonstration of different avoidance levels'}
avoidance_demo(Nanimals, 1.5)
```

### Results

As expected, the mrds estimator is unbiased for p(0) \< 1 when there is no animal movement and no heterogeneity in the population. However, this may not be realistic for most situations. The estimate becomes more negatively biased as the animals move more as a result of the increasing difference in detectability between the two occasions.

```{r mrds-simulation-plotting, echo= F, warning=FALSE, fig.cap="Bias for different levels of animal avoidance"}
p0.bias <- get_p0_bias(50,200) #make reps higher 
plot(p0.bias,pch = 16, xlab = "", ylab = "% Bias")
abline(h = 0, col = "blue", type = "dashed")
legend("bottom", inset=c(0,-0.4), legend=c("No", "Low","Medium", "High"), title="Avoidance", horiz = T, xpd = T)
```

This method also assumes that the observers can identify an individual animal regardless of how far it moves. We investigate the impact of violating this assumption in the next simulation.

## Simulation - Imperfect Matching

### Methods

To see the affect of imperfect matching, we simulated `r Nanimals` animals and had them move in the same way as before. We used the same detection function but did not multiply by 0.8 (i.e. kept p(0) = 1).

To account for the imperfect matching we set that any animals detected on the second occasion within `r match_limits[1]` of an animal detected on the first animal were recorded as the same animal, taking the closest as the match if there were multiple within this range. Any animals further than `r match_limits[2]` were recorded as different, and the probability of matching animals within the range was generated using a hazard rate with parameters `r match_param`.

```{r imperfect-matching, out.width='50%', echo = FALSE, fig.cap = 'Probability of matching animals as distance between them increase'}
x <- seq(0,match_limits[2],0.01)
plot(x, hazard_rate(x,match_param[1],match_param[2]), xlab = "Distance from 1st animal", ylab = "Probability of Match", type = "l")
```

```{r mrds-bias, include=FALSE, warning=FALSE}
#takes ~25 seconds to run one repetition
bias <- get_bias(9, Nanimals)
```

We fitted a half normal mrds model and a hazard rate mrds model to this data and selected the best using AIC, and repeated this process 999 times to estimate bias.

### Results

The MRDS estimator is unbiased for perfect matching and no movement as there is no unmodelled heterogeneity in the population. It isn't significantly biased for scenarios with responsive movement and perfect matching, with an average bias of `r mean(bias[3,5,7])`% across the 3 levels of movement. It is slightly positively biased due to the second observer being able to see less animals than the first as a result of the avoidance. This leads to underestimating the detection probability and so overestimating the abundance.

However, when we add imperfect matching the estimator becomes significantly positively biased. The bias increases as the animals become more avoidant because it becomes more likely that the observers will make a mismatch. As the animals move more, more individuals that were truly seen on both occasions are misidentified as two separate animals that were seen once each on each occasion. This results in a severe underestimate of the detection probability and so the estimate of abundance is significantly positively biased.

```{r mrds-plot, echo = FALSE}
par(xpd = T)
plot(bias[c(1,3,5,7)], ylim = c(-10,100), pch = c(15,16,17,18), main = "Bias by scenario", ylab = "% bias", xlab = "", xaxt = "n")
points(bias[c(2,4,6,8)],pch = c(15,16,17,18), col = "red")
legend("bottom", inset=c(0,-0.4), legend=c("No", "Low","Medium", "High"), pch=c(15,16,17,18), title="Avoidance", horiz = T, xpd = T)
legend("topright", legend = c("Perfect Matching", "Imperfect Matching"), col = c("black", "red"), pch = 16)
```

Hence mrds is only recommended for situations in which the animals are uniquely identifiable. \## Futher Reading

Buckland, S.T., Rexstad, E.A., Marques, T.A. and Oedekoven, C.S. (2015). Distance Sampling: Methods and Applications. Springer International Publish, pp.99--103.

<!--chapter:end:04-mrds.Rmd-->

---
output:
  pdf_document: default
  html_document: default
---

# 2D Distance Sampling

```{r 2D-setup, include=FALSE}
source("code.R")
b = c(5.0174523,0.7224735); logphi = c(6.630331,4.537701)
w = 1600; ystart = 1300
Nanimals = 200
match_limits = c(300,1000); match_param = c(450,5)
```

## Introduction

2D Distance Sampling builds on standard distance sampling by including the forward distance to the detected animal as well as the perpendicular distance. This removes the assumptions that the animals are uniformly distributed and that p(0) = 1, so this method is useful for situations where the other methods covered previously are not suitable. In particular, 2D distance sampling only requires the transect to be surveyed by one observer. This is not only more efficient but removes the issue of imperfect matching in mark-recapture methods.

Animal movement is also less problematic for 2d distance sampling. Like in standard distance sampling, as long as the movement is slow relative to the speed of the observers it will only cause a small amount of bias. Responsive movement can be accounted for in the animal distribution model so does not cause bias.

The likelihood equation for this model is: $$
L(N, \boldsymbol{\beta}) = {N\choose n}[1-p.(\boldsymbol{\beta},\boldsymbol{\phi})]^{N-n}\prod_{i = 1}^{n}\pi(x_i; \boldsymbol{\phi})S(t_i, x_i; \boldsymbol{\beta}) h(t_i, x_i; \boldsymbol{\beta}) 
$$ where:

\- $n$ is the number of animals observed and $N$ is the total in the population

\- $\pi(x_i; \boldsymbol{\phi})$ is the probability animal i is at perpendicular distance $x_i$. We will refer to $\pi(x_i; \boldsymbol{\phi})$ as the animal distribution function.

\- $h(t_i, x_i; \boldsymbol{\beta})$ is the probability animal i is detected at forward distance $y_i$ and perpendicular distance $x_i$. We will refer to $h(t_i, x_i; \boldsymbol{\beta})$ as the detection function.

 - $S(t_i, x_i; \boldsymbol{\beta}) = e^{-\int_{0}^{t_i}h(u,x;\boldsymbol{\beta})du}$ is the survivor function, i.e. the probability that animal i was undetected until time $t_i$ - $p.(\boldsymbol{\beta},\boldsymbol{\phi})]$ is the average probability of being detected in the region

In practice the conditional likelihood $L(\boldsymbol{\beta}|n)$ is used to calculate the maximum likelihood estimators. It is the same as the equation above, but without the leading binomial term, and so avoids considering the unseen animals. The forward distance to the detected animal $y_i$ is used instead of the time $t_i$.

## Simulation: Non Uniform Distribution

We start by simulating attraction to the line by generating 200 animals using a half normal distribution with parameters `r exp(logphi)`. We used a hazard rate detection function with parameters `r b`. The parameters chosen are the best model for the real snow leopard prey data.

```{r 2D-simulation, echo = F, warnings = F}
suppressWarnings(simdata <- MCR_2D(10,Nanimals, b=b, logphi = logphi, w= w, ystart = ystart, match_limits = match_limits, match_params = match_param))
bias_2d <- 100*(simdata$X2D - Nanimals)/Nanimals
```

We then fitted a model using a half normal distribution for animal density and hazard detection function. We did not fit any other models for efficiency purposes. This gives a bias of `r mean(bias_2d)` \pm `r 1.96*sqrt(var(bias_2d)/length(bias_2d))`, so we can confirm it is unbiased.

## Simulation: Comparison to Mark Recapture

Double observer mark recapture methods using the Chapman estimator are the current standard for estimating abundance of snow leopard prey. Our previous simulations have shown these have serious flaws, so we used both a 2D distance model and the Chapman estimator to estimate the abundance from the same data (simulated using the same parameters as above).

```{r 2D-histograms, echo = F, fig.cap="Histograms of abundance estimates using 2D distance sampling and the Chapman estimator"}
par(mfrow = c(1,2))
hist(simdata$X2D, main = "2D Distance", xlab = "Estimate of N")
abline(v = Nanimals, col = "blue")
hist(simdata$MCR.nomvmnt, main = "Chapman", xlab = "Estimate of N", xlim = c(min(simdata$MCR.nomvmnt),max(c(max(simdata$MCR.nomvmnt),Nanimals))))
abline(v = Nanimals, col = "blue")
```

The Chapman estimator was significantly negatively biased due to the unmodelled heterogeneity in the population. Adding random animal movement and imperfect matching gives a similar problem.

```{r imperfect-matching-histograms, echo = F, fig.cap = "Histograms of abundance estimates using the Chapman estimator with random movment"}
par(mfrow = c(1,2))
hist(simdata$MCR.move, main = "Perfect Matching", xlab = "Estimate of N", xlim = c(min(simdata$MCR.move),max(c(max(simdata$MCR.move),Nanimals))))
abline(v = Nanimals, col = "blue")
hist(simdata$MCR.imperf, main = "Imperfect Matching", xlab = "Estimate of N", xlim = c(min(simdata$MCR.imperf), max(c(max(simdata$MCR.imperf)+10,Nanimals))))
abline(v = Nanimals, col = "blue")
```

```{r coverage-probabilities, echo = FALSE}
cis_2D <- simdata[!is.na(simdata$X2D.lower)&!is.na(simdata$X2D.lower), 2:3]
covprob2D <- 100*length(cis_2D[cis_2D$X2D.lower <= Nanimals &cis_2D$X2D.upper >= Nanimals])/length(cis_2D)
cp.nomvmnt <- 100*length(simdata[simdata$nomvmnt.lower <= Nanimals & simdata$nomvmnt.upper >= Nanimals])/length(simdata$MCR.nomvmnt)
if(length(dim(cis_2D)[1] == 0)){
  print("Hessian matrices could not be computed for any 2D models")
  covprob2D <- NA}
cp.mvmnt <- 100*length(simdata[simdata$mvmnt.lower <= Nanimals & simdata$mvmnt.upper >= Nanimals])/length(simdata$MCR.mvmnt)
cp.imperf <- 100*length(simdata[simdata$imperf.lower <= Nanimals & simdata$nimperf.upper >= Nanimals])/length(simdata$MCR.imperf)
kable(data.frame("2D" = covprob2D,"nm" = cp.nomvmnt, "m" = cp.mvmnt,"i" = cp.imperf), col.names = c("2D", "Chapman without movement", "Chapman with movement", "Chapman with imperfect matching"), caption = "Coverage Probabilities")
```

From this it is clear that double-observer mark-recapture will yield significantly biased estimates of abundance of snow leopard prey, even if the animals do not move and the observers can perfectly match the individuals seen. We recommend instead using 2D distance sampling, as it accounts for the non uniform animal distribution as well as the declining detectability with distance. It is also requires less time to be spent surveying, as each transect only need to be walked once.

## Real Data Analysis

### Methods

We will now use the 2D distance framework to analyse the real snow leopard prey data. The observers surveyed 48 transects in 10 blocks and recorded the bearing of the path, the bearing of the group they saw and radial distance to the group where possible. There were 2 species included in the survey: ibex and argali. The observers had limited rangefinders so 49 of these observations had no distance data; 61 groups were behind the observers so did not have a valid "forward" distance. This left 132 usable observations.

Upon closer inspection, many detection distances (both perpendicular and forward) appeared to be rounded to zero, likely as a result of the bearings being rounded to the nearest 5 degrees. To prevent this from impacting the model fit we simply added a small random number to each zero observation.

```{r distance-histograms, fig.cap = "Histograms of forward and perpendicular distances"}
hist(DistData$distance, main = "Perpendicular Distance")
hist(DistData$forward, main = "Forward Distance")
```

From looking at the histograms of observed data we set the perpendicular truncation distance at `r w1` and the forward truncation distance at `r ystart1`. This excluded 2 outlier observations.\
We then fitted a series of model with different detection functions and animal distributions, and picked the one with the lowest AIC.

### Results

```{r fit-model, include = FALSE, warning=FALSE }
jitter.h1.norm <- LT2D.fit(DataFrameInput = jitterdf, 
                           hr = 'h1',
                           b = c(log(100),log(2)),
                           ystart = ystart,      
                           pi.x = 'pi.norm',   
                           logphi = c(0,5),
                           w = w,
                           hessian = TRUE)
ibexjitter.h1.norm <- LT2D.fit(DataFrameInput = ibexjitter, 
                               hr = 'h1',
                               b = c(log(100),log(2)),
                               ystart = ystart,      
                               pi.x = 'pi.norm',   
                               logphi = c(0,5),
                               w = w,
                               hessian = TRUE)
argalijitter.h1 <- LT2D.fit(DataFrameInput = argalijitter,
                            hr = 'h1',
                            b = c(4.5, 0.75),
                            ystart = ystart,
                            pi.x = 'pi.const',
                            w = w,
                            hessian = TRUE)
boot <- LT2D.bootstrap(jitter.h1.norm, r = 999, alpha = 0.05)
ibexboot <- LT2D.bootstrap(ibexjitter.h1.norm, r = 999, alpha = 0.05)
argaliboot <- LT2D.bootstrap(argalijitter.h1, r = 999, alpha = 0.05)
total.N <- jitter.h1.norm$ests[nrow(jitter.h1.norm$ests),ncol(jitter.h1.norm$ests)]
total.ibex <- ibexjitter.h1.norm$ests[nrow(ibexjitter.h1.hnorm$ests),ncol(ibexjitter.h1.norm$ests)]
total.argali <- argalijitter.h1$ests[nrow(argalijitter.h1$ests),ncol(argalijitter.h1$ests)]
```

Our best fitting model used the h1 hazard detection function and a normal distribution for the animal density. All of the best fitting models used a normal animal distribution, which implies that the animals are attracted to the line rather than avoiding it as initially thought. This could be due to the non random line placement, as the observers travel along valleys or ridges that are easier to walk along so the animals could also favour the easier terrain.

```{r real-results-plot,echo = F, fig.cap = "Detection and distribution functions for best model (h1 and normal)"}
par(mfrow = c(2,2))
plot(jitter.h1.norm)
test.results <- gof.LT2D(jitter.h1.norm, plot = T)
```

We tried fitting different models to each species in the survey, but this had a higher AIC than the combined model (`r ibexjitter.h1.norm$fit$AIC + argalijitter.h1$fit$AIC` vs `r jitter.h1.norm$fit$AIC` for combined model). Interestingly, the argali appear to be uniformly distributed across the area whereas the ibex exhibit line attraction. However, there are only 37 argali groups recorded so further investigation is needed before drawing any conclusions.

The best combined model estimates there are `r total.N` individual animals in total.

```{r confidence-tables, echo = F, fig.margin = T}
ci.tabs <- data.frame("N" = c(total.N, total.ibex, total.argali), "95% CI L" = c(boot$ci[1], ibexboot$ci[1], argaliboot$ci[1]), "95%  CI U"= c(boot$ci[2], ibexboot$ci[2], argaliboot$ci[2]), row.names = c("Combined model", "Ibex only model", "Argali only model"))
kable(ci.tabs, col.names = c("Point Estimate","95% Bootstrap", "Confidence Interval"))
```

```{r estimate-by-block, echo = F}
ests <- jitter.h1.norm$ests[,c(1,2,4,6,7:11)]
rownames(ests) <- NULL
kable(ests, col.names = c("Stratum", "Groups Seen", "Total Transect Length ($km$)", "Stratum Area ($m^2$)", "Estimated Group Denisty", "Number of Groups", "Mean Size", "Individual Density", "Abundance Estimate" ), escape = FALSE)
```

## Further Reading

Borchers, D.L. and Cox, M.J. (2016). Distance sampling detection functions: 2D or not 2D? Biometrics, 73(2), pp.593--602. <doi:https://doi.org/10.1111/biom.12581>.

Borchers, D.L., Buckland, S.T. and Zucchini, W. (2002). Estimating Animal Abundance. [online] Springer Science & Business Media.

Suryawanshi, K.R., Bhatnagar, Y.V. and Mishra, C. (2012). Standardizing the double-observer survey method for estimating mountain ungulate prey of the endangered snow leopard. Oecologia, 169(3), pp.581--590. <doi:https://doi.org/10.1007/s00442-011-2237-0>.

<!--chapter:end:05-2d-distance.Rmd-->

# Sharing your book

## Publishing

HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html

## 404 pages

By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you'd like to customize your 404 page instead of using the default, you may add either a `_404.Rmd` or `_404.md` file to your project root and use code and/or Markdown syntax.

## Metadata for sharing

Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the `index.Rmd` YAML. To setup, set the `url` for your book and the path to your `cover-image` file. Your book's `title` and `description` are also used.



This `gitbook` uses the same social sharing data across all chapters in your book- all links shared will look the same.

Specify your book's source repository on GitHub using the `edit` key under the configuration options in the `_output.yml` file, which allows users to suggest an edit by linking to a chapter's source file. 

Read more about the features of this output format here:

https://pkgs.rstudio.com/bookdown/reference/gitbook.html

Or use:

```{r eval=FALSE}
?bookdown::gitbook
```



<!--chapter:end:06-share.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:07-references.Rmd-->

# 2D Distance Sampling
```{r, include=FALSE}
source("code.R")
b1 = c(4.945767, 0.714222); logphi1 = c(6.520254,4.754897) 
w1 = 1500; ystart1 = 1300
```
## Introduction
2D Distance Sampling builds on standard distance sampling by including the forward distance to the detected animal as well as the perpendicular distance. This removes the assumptions that the animals are uniformly distributed and that p(0) = 1, so this method is useful for situations where the other methods covered previously are not suitable. 

##Simulation - Non Uniform Distribution
We start by simulating attraction to the line by generating 200 animals using a half normal distribution with parameters `r exp(logphi)`. We used a hazard rate detection function with parameters `r b`. The parameters chosen are the best model for our real data.  
```{r, echo = F, warnings = F}
suppressWarnings(simdata <- MCR_2D(99,200))
bias_2d <- 100*(simdata$X2D - 200)/200
```
We then fitted a model using a half normal distribution for animal density and hazard detection function. We did not fit any other models for efficiency purposes. This gives a bias of `r mean(bias_2d)` \pm `r 1.96*sqrt(var(bias_2d)/length(bias_2d))`, so we can confirm it is unbiased. 
## Simulation - Comparison to Mark Recapture
Double Observer mark recapture methods are the current standard for estimating abundance of snow leopard prey. Our previous simulations have shown these have serious flaws, so we used both a 2D distance model and the Chapman estimator to estimate the abundance from the same data (simulated using the same parameters as above).
```{r, echo = F, fig.cap="Histograms of abundance estimates using 2D distance sampling and the Chapman estimator"}
par(mfrow = c(1,2))
hist(simdata$X2D, main = "2D Distance", xlab = "Estimate of N")
abline(v = 200, col = "blue")
hist(simdata$MCR.nomvmnt, main = "Chapman", xlab = "Estimate of N", xlim = c(min(simdata$MCR.nomvmnt),max(c(max(simdata$MCR.nomvmnt),200))))
abline(v = 200, col = "blue")
```
The Chapman estimator was significantly negatively biased due to the unmodelled heterogeneity in the population. Adding random animal movement and imperfect matching gives a similar problem.  
```{r, echo = F, fig.cap = "Histograms of abundance estimates using the Chapman estimator with random movment"}
par(mfrow = c(1,2))
hist(simdata$MCR.move, main = "Perfect Matching", xlab = "Estimate of N", xlim = c(min(simdata$MCR.move),max(c(max(simdata$MCR.move),200))))
abline(v = 200, col = "blue")
hist(simdata$MCR.imperf, main = "Imperfect Matching", xlab = "Estimate of N", xlim = c(min(simdata$MCR.imperf), max(c(max(simdata$MCR.imperf)+10,200))))
abline(v = 200, col = "blue")
```
From this it is clear that double-observer mark-recapture will yield significantly biased estimates of abundance of snow leopard prey, even if the animals do not move and the observers can perfectly match the individuals seen. We recommend instead using 2D distance sampling, as it accounts for the non uniform animal distribution as well as the declining detectability with distance. It is also requires less time to be spent surveying, as each transect only need to be walked once. 


##Further Reading
Borchers, D.L. and Cox, M.J. (2016). Distance sampling detection functions: 2D or not 2D? Biometrics, 73(2), pp.593602. doi:https://doi.org/10.1111/biom.12581.

Suryawanshi, K.R., Bhatnagar, Y.V. and Mishra, C. (2012). Standardizing the double-observer survey method for estimating mountain ungulate prey of the endangered snow leopard. Oecologia, 169(3), pp.581590. doi:https://doi.org/10.1007/s00442-011-2237-0.

<!--chapter:end:2d-distance.Rmd-->

